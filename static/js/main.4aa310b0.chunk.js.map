{"version":3,"sources":["chat_message.ts","../../../../src/lib/waku.ts","../../../../../../src/proto/waku/v2/message.ts","../../../../../src/lib/waku_message/index.ts","../../../../../src/lib/waku_relay/constants.ts","App.tsx","Message.ts","../../../../../../src/lib/waku_message/symmetric/index.ts","../../../../../src/lib/waku_relay/index.ts","../../../../../../src/proto/waku/v2/store.ts","proto/chat_message.ts","../../../../src/lib/discovery.ts","../../../../src/lib/utils.ts","../../../../../src/lib/waku_light_push/index.ts","../../../../../../src/proto/waku/v2/light_push.ts","../../../../src/lib/select_peer.ts","../../../../../src/lib/waku_message/version_1.ts","../../../../../src/lib/waku_relay/get_relay_peers.ts","../../../../../src/lib/waku_store/index.ts","command.ts","ChatList.tsx","MessageInput.tsx","Room.tsx","index.tsx","../../../../../src/lib/waku_light_push/push_rpc.ts","../../../../../../src/lib/waku_message/symmetric/browser.ts","../../../../../../src/lib/waku_message/symmetric/node.ts","../../../../../src/lib/waku_relay/relay_heartbeat.ts","../../../../../src/lib/waku_store/history_rpc.ts","../../../../src/proto/index.ts","../../../src/index.ts","WakuContext.ts"],"names":["ChatMessage","proto","encode","this","finish","Date","timestamp","nick","payload","Buffer","from","toString","text","Math","floor","valueOf","bytes","decode","Reader","create","message","global","themes","AuthorName","css","fontSize","Message","margin","padding","MessageText","paddingLeft","MessageGroup","ChatContentTopic","waku","setArchivedMessages","a","callback","wakuMessages","messages","map","wakuMsg","fromWakuMessage","forEach","push","startTime","setTime","now","endTime","store","queryHistory","pageSize","direction","Direction","FORWARD","timeFilter","res","length","console","log","App","useReducer","reduceMessages","dispatchMessages","useState","undefined","setWaku","persistedNick","window","localStorage","getItem","generate","setNick","historicalMessagesRetrieved","setHistoricalMessagesRetrieved","useEffect","setItem","initWaku","then","catch","e","handleRelayMessage","msg","relay","addObserver","deleteObserver","checkAndRetrieve","protocols","includes","StoreCodec","retrieveStoreMessages","libp2p","peerStore","on","removeListener","className","style","height","width","overflow","Provider","value","theme","commandHandler","input","handleCommand","command","commandMessages","response","fromUtf8String","setter","Waku","config","pubsub","enabled","emitSelf","bootstrap","getBootstrapNodes","bind","selectFleetEnv","process","NODE_ENV","state","newMessages","concat","chatMessage","sentTimestamp","payloadAsUtf8","chatMsg","error","PagingInfo_Direction","exports","pagingInfo_DirectionToJSON","baseChatMessage","writer","_m0","Writer","uint32","uint64","string","reader","end","len","pos","Uint8Array","tag","longToNumber","skipType","fromJSON","object","Number","String","b64","bin","atob","arr","i","charCodeAt","bytesFromBase64","toJSON","obj","byte","fromCharCode","btoa","join","base64FromBytes","fromPartial","globalThis","self","long","gt","MAX_SAFE_INTEGER","Error","toNumber","util","Long","configure","nodes","buf","readUIntLE","args","trim","replaceAll","split","parseInput","shift","str","peerId","toB58String","info","peer","peerMultiaddr","multiaddr","getPeerId","addPeerToAddressBook","PeerId","createFromB58String","connect","peers","addresses","replace","connections","strConnections","connection","JSON","stringify","stat","streams","ChatList","props","renderedMessages","authorName","date","formatDisplayDate","active","containScrollInSubtree","toLocaleString","month","day","hour","minute","hour12","AlwaysScrollToBottom","elementRef","useRef","current","scrollIntoView","ref","MessageInput","inputText","setInputText","useWaku","sendMessage","keyPressHandler","event","key","altKey","ctrlKey","shiftKey","activeButton","getPeers","size","startsWith","onKeyDown","onChange","target","onButtonClick","align","Room","relayPeers","storePeers","display","flexDirection","leftIcons","title","messageToSend","handleMessage","send","messageSender","WakuMessage","fromBytes","ReactDOM","render","StrictMode","document","getElementById","gossipsub","outbound","WakuContext","createContext","useContext"],"mappings":"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","file":"static/js/main.4aa310b0.chunk.js","sourcesContent":["import { Reader } from 'protobufjs/minimal';\n\nimport * as proto from './proto/chat_message';\n\n/**\n * ChatMessage is used by the various show case waku apps that demonstrates\n * waku used as the network layer for chat group applications.\n *\n * This is included to help building PoC and MVPs. Apps that aim to be\n * production ready should use a more appropriate data structure.\n */\nexport class ChatMessage {\n  public constructor(public proto: proto.ChatMessage) {}\n\n  /**\n   * Create Chat Message with a utf-8 string as payload.\n   */\n  static fromUtf8String(\n    timestamp: Date,\n    nick: string,\n    text: string\n  ): ChatMessage {\n    const timestampNumber = Math.floor(timestamp.valueOf() / 1000);\n    const payload = Buffer.from(text, 'utf-8');\n\n    return new ChatMessage({\n      timestamp: timestampNumber,\n      nick,\n      payload,\n    });\n  }\n\n  /**\n   * Decode a protobuf payload to a ChatMessage.\n   * @param bytes The payload to decode.\n   */\n  static decode(bytes: Uint8Array): ChatMessage {\n    const protoMsg = proto.ChatMessage.decode(Reader.create(bytes));\n    return new ChatMessage(protoMsg);\n  }\n\n  /**\n   * Encode this ChatMessage to a byte array, to be used as a protobuf payload.\n   * @returns The encoded payload.\n   */\n  encode(): Uint8Array {\n    return proto.ChatMessage.encode(this.proto).finish();\n  }\n\n  get timestamp(): Date {\n    return new Date(this.proto.timestamp * 1000);\n  }\n\n  get nick(): string {\n    return this.proto.nick;\n  }\n\n  get payloadAsUtf8(): string {\n    if (!this.proto.payload) {\n      return '';\n    }\n\n    return Buffer.from(this.proto.payload).toString('utf-8');\n  }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Waku = exports.DefaultPubSubTopic = exports.DefaultRelayKeepAliveValueSecs = exports.DefaultPingKeepAliveValueSecs = void 0;\nconst noise_1 = require(\"@chainsafe/libp2p-noise/dist/src/noise\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst libp2p_1 = __importDefault(require(\"libp2p\"));\nconst libp2p_bootstrap_1 = __importDefault(require(\"libp2p-bootstrap\"));\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore: No types available\nconst libp2p_mplex_1 = __importDefault(require(\"libp2p-mplex\"));\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore: No types available\nconst libp2p_websockets_1 = __importDefault(require(\"libp2p-websockets\"));\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore: No types available\nconst filters_1 = __importDefault(require(\"libp2p-websockets/src/filters\"));\nconst ping_1 = __importDefault(require(\"libp2p/src/ping\"));\nconst multiaddr_1 = require(\"multiaddr\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst discovery_1 = require(\"./discovery\");\nconst waku_light_push_1 = require(\"./waku_light_push\");\nconst waku_message_1 = require(\"./waku_message\");\nconst waku_relay_1 = require(\"./waku_relay\");\nconst constants_1 = require(\"./waku_relay/constants\");\nconst waku_store_1 = require(\"./waku_store\");\nconst websocketsTransportKey = libp2p_websockets_1.default.prototype[Symbol.toStringTag];\nexports.DefaultPingKeepAliveValueSecs = 0;\nexports.DefaultRelayKeepAliveValueSecs = 5 * 60;\n/**\n * DefaultPubSubTopic is the default gossipsub topic to use for Waku.\n */\nexports.DefaultPubSubTopic = '/waku/2/default-waku/proto';\nconst dbg = debug_1.default('waku:waku');\nclass Waku {\n    constructor(options, libp2p, store, lightPush) {\n        this.libp2p = libp2p;\n        this.relay = libp2p.pubsub;\n        this.store = store;\n        this.lightPush = lightPush;\n        this.pingKeepAliveTimers = {};\n        this.relayKeepAliveTimers = {};\n        const pingKeepAlive = options.pingKeepAlive || exports.DefaultPingKeepAliveValueSecs;\n        const relayKeepAlive = options.relayKeepAlive || exports.DefaultRelayKeepAliveValueSecs;\n        libp2p.connectionManager.on('peer:connect', (connection) => {\n            this.startKeepAlive(connection.remotePeer, pingKeepAlive, relayKeepAlive);\n        });\n        libp2p.connectionManager.on('peer:disconnect', (connection) => {\n            this.stopKeepAlive(connection.remotePeer);\n        });\n    }\n    /**\n     * Create new waku node\n     *\n     * @param options Takes the same options than `Libp2p`.\n     */\n    static async create(options) {\n        var _a, _b, _c;\n        // Get an object in case options or libp2p are undefined\n        const libp2pOpts = Object.assign({}, options === null || options === void 0 ? void 0 : options.libp2p);\n        // Default for Websocket filter is `all`:\n        // Returns all TCP and DNS based addresses, both with ws or wss.\n        libp2pOpts.config = Object.assign({\n            transport: {\n                [websocketsTransportKey]: {\n                    filter: filters_1.default.all,\n                },\n            },\n        }, (_a = options === null || options === void 0 ? void 0 : options.libp2p) === null || _a === void 0 ? void 0 : _a.config);\n        // Pass pubsub topic to relay\n        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {\n            libp2pOpts.config.pubsub = Object.assign({ pubSubTopic: options.pubSubTopic }, libp2pOpts.config.pubsub);\n        }\n        libp2pOpts.modules = Object.assign({}, (_b = options === null || options === void 0 ? void 0 : options.libp2p) === null || _b === void 0 ? void 0 : _b.modules);\n        // Default transport for libp2p is Websockets\n        libp2pOpts.modules = Object.assign({\n            transport: [libp2p_websockets_1.default],\n        }, (_c = options === null || options === void 0 ? void 0 : options.libp2p) === null || _c === void 0 ? void 0 : _c.modules);\n        // streamMuxer, connection encryption and pubsub are overridden\n        // as those are the only ones currently supported by Waku nodes.\n        libp2pOpts.modules = Object.assign(libp2pOpts.modules, {\n            streamMuxer: [libp2p_mplex_1.default],\n            connEncryption: [new noise_1.Noise(options === null || options === void 0 ? void 0 : options.staticNoiseKey)],\n            pubsub: waku_relay_1.WakuRelay,\n        });\n        if (options === null || options === void 0 ? void 0 : options.bootstrap) {\n            let bootstrap;\n            if (options.bootstrap === true) {\n                bootstrap = discovery_1.getBootstrapNodes;\n            }\n            else if (Array.isArray(options.bootstrap)) {\n                bootstrap = () => {\n                    return options.bootstrap;\n                };\n            }\n            else if (typeof options.bootstrap === 'function') {\n                bootstrap = options.bootstrap;\n            }\n            if (bootstrap !== undefined) {\n                // Note: this overrides any other peer discover\n                libp2pOpts.modules = Object.assign(libp2pOpts.modules, {\n                    peerDiscovery: [libp2p_bootstrap_1.default],\n                });\n                try {\n                    const list = await bootstrap();\n                    libp2pOpts.config.peerDiscovery = {\n                        [libp2p_bootstrap_1.default.tag]: {\n                            list,\n                            enabled: true,\n                        },\n                    };\n                }\n                catch (e) {\n                    dbg('Failed to retrieve bootstrap nodes', e);\n                }\n            }\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: modules property is correctly set thanks to voodoo\n        const libp2p = await libp2p_1.default.create(libp2pOpts);\n        const wakuStore = new waku_store_1.WakuStore(libp2p, {\n            pubSubTopic: options === null || options === void 0 ? void 0 : options.pubSubTopic,\n        });\n        const wakuLightPush = new waku_light_push_1.WakuLightPush(libp2p);\n        await libp2p.start();\n        return new Waku(options ? options : {}, libp2p, wakuStore, wakuLightPush);\n    }\n    /**\n     * Dials to the provided peer.\n     *\n     * @param peer The peer to dial\n     */\n    async dial(peer) {\n        return this.libp2p.dialProtocol(peer, [waku_store_1.StoreCodec].concat(waku_relay_1.RelayCodecs));\n    }\n    /**\n     * Add peer to address book, it will be auto-dialed in the background.\n     */\n    addPeerToAddressBook(peerId, multiaddrs) {\n        let peer;\n        if (typeof peerId === 'string') {\n            peer = peer_id_1.default.createFromB58String(peerId);\n        }\n        else {\n            peer = peerId;\n        }\n        const addresses = multiaddrs.map((addr) => {\n            if (typeof addr === 'string') {\n                return multiaddr_1.multiaddr(addr);\n            }\n            else {\n                return addr;\n            }\n        });\n        this.libp2p.peerStore.addressBook.set(peer, addresses);\n    }\n    async stop() {\n        return this.libp2p.stop();\n    }\n    /**\n     * Return the local multiaddr with peer id on which libp2p is listening.\n     * @throws if libp2p is not listening on localhost\n     */\n    getLocalMultiaddrWithID() {\n        const localMultiaddr = this.libp2p.multiaddrs.find((addr) => addr.toString().match(/127\\.0\\.0\\.1/));\n        if (!localMultiaddr || localMultiaddr.toString() === '') {\n            throw 'Not listening on localhost';\n        }\n        return localMultiaddr + '/p2p/' + this.libp2p.peerId.toB58String();\n    }\n    startKeepAlive(peerId, pingPeriodSecs, relayPeriodSecs) {\n        // Just in case a timer already exist for this peer\n        this.stopKeepAlive(peerId);\n        const peerIdStr = peerId.toB58String();\n        if (pingPeriodSecs !== 0) {\n            this.pingKeepAliveTimers[peerIdStr] = setInterval(() => {\n                ping_1.default(this.libp2p, peerId);\n            }, pingPeriodSecs * 1000);\n        }\n        if (relayPeriodSecs !== 0) {\n            this.relayKeepAliveTimers[peerIdStr] = setInterval(() => {\n                waku_message_1.WakuMessage.fromBytes(new Uint8Array(), constants_1.RelayPingContentTopic).then((wakuMsg) => this.relay.send(wakuMsg));\n            }, relayPeriodSecs * 1000);\n        }\n    }\n    stopKeepAlive(peerId) {\n        const peerIdStr = peerId.toB58String();\n        if (this.pingKeepAliveTimers[peerIdStr]) {\n            clearInterval(this.pingKeepAliveTimers[peerIdStr]);\n            delete this.pingKeepAliveTimers[peerIdStr];\n        }\n        if (this.relayKeepAliveTimers[peerIdStr]) {\n            clearInterval(this.relayKeepAliveTimers[peerIdStr]);\n            delete this.relayKeepAliveTimers[peerIdStr];\n        }\n    }\n}\nexports.Waku = Waku;\n//# sourceMappingURL=waku.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuMessage = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nexports.protobufPackage = 'waku.v2';\nconst baseWakuMessage = {};\nexports.WakuMessage = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.payload !== undefined) {\n            writer.uint32(10).bytes(message.payload);\n        }\n        if (message.contentTopic !== undefined) {\n            writer.uint32(18).string(message.contentTopic);\n        }\n        if (message.version !== undefined) {\n            writer.uint32(24).uint32(message.version);\n        }\n        if (message.timestamp !== undefined) {\n            writer.uint32(33).double(message.timestamp);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseWakuMessage);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.payload = reader.bytes();\n                    break;\n                case 2:\n                    message.contentTopic = reader.string();\n                    break;\n                case 3:\n                    message.version = reader.uint32();\n                    break;\n                case 4:\n                    message.timestamp = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseWakuMessage);\n        if (object.payload !== undefined && object.payload !== null) {\n            message.payload = bytesFromBase64(object.payload);\n        }\n        if (object.contentTopic !== undefined && object.contentTopic !== null) {\n            message.contentTopic = String(object.contentTopic);\n        }\n        else {\n            message.contentTopic = undefined;\n        }\n        if (object.version !== undefined && object.version !== null) {\n            message.version = Number(object.version);\n        }\n        else {\n            message.version = undefined;\n        }\n        if (object.timestamp !== undefined && object.timestamp !== null) {\n            message.timestamp = Number(object.timestamp);\n        }\n        else {\n            message.timestamp = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.payload !== undefined &&\n            (obj.payload =\n                message.payload !== undefined\n                    ? base64FromBytes(message.payload)\n                    : undefined);\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        message.version !== undefined && (obj.version = message.version);\n        message.timestamp !== undefined && (obj.timestamp = message.timestamp);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseWakuMessage);\n        if (object.payload !== undefined && object.payload !== null) {\n            message.payload = object.payload;\n        }\n        else {\n            message.payload = undefined;\n        }\n        if (object.contentTopic !== undefined && object.contentTopic !== null) {\n            message.contentTopic = object.contentTopic;\n        }\n        else {\n            message.contentTopic = undefined;\n        }\n        if (object.version !== undefined && object.version !== null) {\n            message.version = object.version;\n        }\n        else {\n            message.version = undefined;\n        }\n        if (object.timestamp !== undefined && object.timestamp !== null) {\n            message.timestamp = object.timestamp;\n        }\n        else {\n            message.timestamp = undefined;\n        }\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== 'undefined')\n        return globalThis;\n    if (typeof self !== 'undefined')\n        return self;\n    if (typeof window !== 'undefined')\n        return window;\n    if (typeof global !== 'undefined')\n        return global;\n    throw 'Unable to locate global object';\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(''));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=message.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuMessage = void 0;\n// Ensure that this class matches the proto interface while\nconst buffer_1 = require(\"buffer\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst minimal_1 = require(\"protobufjs/minimal\");\n// Protecting the user from protobuf oddities\nconst proto = __importStar(require(\"../../proto/waku/v2/message\"));\nconst version_1 = __importStar(require(\"./version_1\"));\nconst DefaultVersion = 0;\nconst dbg = debug_1.default('waku:message');\nclass WakuMessage {\n    constructor(proto, _signaturePublicKey, _signature) {\n        this.proto = proto;\n        this._signaturePublicKey = _signaturePublicKey;\n        this._signature = _signature;\n    }\n    /**\n     * Create Message with a utf-8 string as payload.\n     */\n    static async fromUtf8String(utf8, contentTopic, opts) {\n        const payload = buffer_1.Buffer.from(utf8, 'utf-8');\n        return WakuMessage.fromBytes(payload, contentTopic, opts);\n    }\n    /**\n     * Create a Waku Message with the given payload.\n     *\n     * By default, the payload is kept clear (version 0).\n     * If `opts.encPublicKey` is passed, the payload is encrypted using\n     * asymmetric encryption (version 1).\n     *\n     * If `opts.sigPrivKey` is passed and version 1 is used, the payload is signed\n     * before encryption.\n     *\n     * @throws if both `opts.encPublicKey` and `opt.symKey` are passed\n     */\n    static async fromBytes(payload, contentTopic, opts) {\n        const { timestamp, encPublicKey, symKey, sigPrivKey } = Object.assign({ timestamp: new Date() }, opts ? opts : {});\n        let _payload = payload;\n        let version = DefaultVersion;\n        let sig;\n        if (encPublicKey && symKey) {\n            throw 'Pass either `encPublicKey` or `symKey`, not both.';\n        }\n        if (encPublicKey) {\n            const enc = version_1.clearEncode(_payload, sigPrivKey);\n            _payload = await version_1.encryptAsymmetric(enc.payload, encPublicKey);\n            sig = enc.sig;\n            version = 1;\n        }\n        else if (symKey) {\n            const enc = version_1.clearEncode(_payload, sigPrivKey);\n            _payload = await version_1.encryptSymmetric(enc.payload, symKey);\n            sig = enc.sig;\n            version = 1;\n        }\n        return new WakuMessage({\n            payload: _payload,\n            timestamp: timestamp.valueOf() / 1000,\n            version,\n            contentTopic,\n        }, sig === null || sig === void 0 ? void 0 : sig.publicKey, sig === null || sig === void 0 ? void 0 : sig.signature);\n    }\n    /**\n     * Decode a byte array into Waku Message.\n     *\n     * @params bytes The message encoded using protobuf as defined in [14/WAKU2-MESSAGE](https://rfc.vac.dev/spec/14/).\n     * @params decryptionKeys If the payload is encrypted (version = 1), then the\n     * keys are used to attempt decryption of the message. The passed key can either\n     * be asymmetric private keys or symmetric keys, both method are tried for each\n     * key until the message is decrypted or combinations are ran out.\n     */\n    static async decode(bytes, decryptionKeys) {\n        const protoBuf = proto.WakuMessage.decode(minimal_1.Reader.create(bytes));\n        return WakuMessage.decodeProto(protoBuf, decryptionKeys);\n    }\n    /**\n     * Decode and decrypt Waku Message Protobuf Object into Waku Message.\n     *\n     * @params protoBuf The message to decode and decrypt.\n     * @params decryptionKeys If the payload is encrypted (version = 1), then the\n     * keys are used to attempt decryption of the message. The passed key can either\n     * be asymmetric private keys or symmetric keys, both method are tried for each\n     * key until the message is decrypted or combinations are ran out.\n     */\n    static async decodeProto(protoBuf, decryptionKeys) {\n        var _a, _b;\n        if (protoBuf.payload === undefined) {\n            dbg('Payload is undefined');\n            return;\n        }\n        const payload = protoBuf.payload;\n        let signaturePublicKey;\n        let signature;\n        if (protoBuf.version === 1 && protoBuf.payload) {\n            if (decryptionKeys === undefined) {\n                dbg('Payload is encrypted but no private keys have been provided.');\n                return;\n            }\n            // Returns a bunch of `undefined` and hopefully one decrypted result\n            const allResults = await Promise.all(decryptionKeys.map(async (privateKey) => {\n                try {\n                    return await version_1.decryptSymmetric(payload, privateKey);\n                }\n                catch (e) {\n                    dbg('Failed to decrypt message using symmetric encryption', e);\n                    try {\n                        return await version_1.decryptAsymmetric(payload, privateKey);\n                    }\n                    catch (e) {\n                        dbg('Failed to decrypt message using asymmetric encryption', e);\n                        return;\n                    }\n                }\n            }));\n            const isDefined = (dec) => {\n                return !!dec;\n            };\n            const decodedResults = allResults.filter(isDefined);\n            if (decodedResults.length === 0) {\n                dbg('Failed to decrypt payload.');\n                return;\n            }\n            const dec = decodedResults[0];\n            const res = await version_1.clearDecode(dec);\n            if (!res) {\n                dbg('Failed to decode payload.');\n                return;\n            }\n            Object.assign(protoBuf, { payload: res.payload });\n            signaturePublicKey = (_a = res.sig) === null || _a === void 0 ? void 0 : _a.publicKey;\n            signature = (_b = res.sig) === null || _b === void 0 ? void 0 : _b.signature;\n        }\n        return new WakuMessage(protoBuf, signaturePublicKey, signature);\n    }\n    encode() {\n        return proto.WakuMessage.encode(this.proto).finish();\n    }\n    get payloadAsUtf8() {\n        if (!this.proto.payload) {\n            return '';\n        }\n        return buffer_1.Buffer.from(this.proto.payload).toString('utf-8');\n    }\n    get payload() {\n        return this.proto.payload;\n    }\n    get contentTopic() {\n        return this.proto.contentTopic;\n    }\n    get version() {\n        return this.proto.version;\n    }\n    get timestamp() {\n        if (this.proto.timestamp) {\n            return new Date(this.proto.timestamp * 1000);\n        }\n        return;\n    }\n    /**\n     * The public key used to sign the message.\n     *\n     * MAY be present if the message is version 1.\n     */\n    get signaturePublicKey() {\n        return this._signaturePublicKey;\n    }\n    /**\n     * The signature of the message.\n     *\n     * MAY be present if the message is version 1.\n     */\n    get signature() {\n        return this._signature;\n    }\n}\nexports.WakuMessage = WakuMessage;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RelayMaxIHaveLength = exports.RelayOpportunisticGraftPeers = exports.RelayOpportunisticGraftTicks = exports.RelayFanoutTTL = exports.RelayPruneBackoff = exports.RelayPrunePeers = exports.RelayHeartbeatInterval = exports.RelayHeartbeatInitialDelay = exports.RelayGossipFactor = exports.RelayPingContentTopic = exports.RelayCodecs = exports.minute = exports.second = void 0;\nexports.second = 1000;\nexports.minute = 60 * exports.second;\n/**\n * RelayCodec is the libp2p identifier for the waku relay protocol\n */\nexports.RelayCodecs = [\n    '/vac/waku/relay/2.0.0-beta2',\n    '/vac/waku/relay/2.0.0',\n];\nexports.RelayPingContentTopic = '/relay-ping/1/ping/null';\n/**\n * RelayGossipFactor affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to RelayGossipFactor * (total number of non-mesh peers), or\n * RelayDlazy, whichever is greater.\n */\nexports.RelayGossipFactor = 0.25;\n/**\n * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins\n * after the router is initialized.\n */\nexports.RelayHeartbeatInitialDelay = 100;\n/**\n * RelayHeartbeatInterval controls the time between heartbeats.\n */\nexports.RelayHeartbeatInterval = exports.second;\n/**\n * RelayPrunePeers controls the number of peers to include in prune Peer eXchange.\n * When we prune a peer that's eligible for PX (has a good score, etc), we will try to\n * send them signed peer records for up to RelayPrunePeers other peers that we\n * know of.\n */\nexports.RelayPrunePeers = 16;\n/**\n * RelayPruneBackoff controls the backoff time for pruned peers. This is how long\n * a peer must wait before attempting to graft into our mesh again after being pruned.\n * When pruning a peer, we send them our value of RelayPruneBackoff so they know\n * the minimum time to wait. Peers running older versions may not send a backoff time,\n * so if we receive a prune message without one, we will wait at least RelayPruneBackoff\n * before attempting to re-graft.\n */\nexports.RelayPruneBackoff = exports.minute;\n/**\n * RelayFanoutTTL controls how long we keep track of the fanout state. If it's been\n * RelayFanoutTTL since we've published to a topic that we're not subscribed to,\n * we'll delete the fanout map for that topic.\n */\nexports.RelayFanoutTTL = exports.minute;\n/**\n * RelayOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh\n * with opportunistic grafting. Every RelayOpportunisticGraftTicks we will attempt to select some\n * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls\n * below a threshold\n */\nexports.RelayOpportunisticGraftTicks = 60;\n/**\n * RelayOpportunisticGraftPeers is the number of peers to opportunistically graft.\n */\nexports.RelayOpportunisticGraftPeers = 2;\n/**\n * RelayMaxIHaveLength is the maximum number of messages to include in an IHAVE message.\n * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a\n * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the\n * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;\n * with the defaults this is 1666 messages/s.\n */\nexports.RelayMaxIHaveLength = 5000;\n//# sourceMappingURL=constants.js.map","import { useEffect, useReducer, useState } from 'react';\nimport './App.css';\nimport {\n  Direction,\n  getBootstrapNodes,\n  StoreCodec,\n  Waku,\n  WakuMessage,\n} from 'js-waku';\nimport handleCommand from './command';\nimport Room from './Room';\nimport { WakuContext } from './WakuContext';\nimport { ThemeProvider } from '@livechat/ui-kit';\nimport { generate } from 'server-name-generator';\nimport { Message } from './Message';\n\nconst themes = {\n  AuthorName: {\n    css: {\n      fontSize: '1.1em',\n    },\n  },\n  Message: {\n    css: {\n      margin: '0em',\n      padding: '0em',\n      fontSize: '0.83em',\n    },\n  },\n  MessageText: {\n    css: {\n      margin: '0em',\n      padding: '0.1em',\n      paddingLeft: '1em',\n      fontSize: '1.1em',\n    },\n  },\n  MessageGroup: {\n    css: {\n      margin: '0em',\n      padding: '0.2em',\n    },\n  },\n};\n\nexport const ChatContentTopic = '/toy-chat/2/huilong/proto';\n\nasync function retrieveStoreMessages(\n  waku: Waku,\n  setArchivedMessages: (value: Message[]) => void\n): Promise<number> {\n  const callback = (wakuMessages: WakuMessage[]): void => {\n    const messages: Message[] = [];\n    wakuMessages\n      .map((wakuMsg) => Message.fromWakuMessage(wakuMsg))\n      .forEach((message) => {\n        if (message) {\n          messages.push(message);\n        }\n      });\n    setArchivedMessages(messages);\n  };\n\n  const startTime = new Date();\n  // Only retrieve a week of history\n  startTime.setTime(Date.now() - 1000 * 60 * 60 * 24 * 7);\n\n  const endTime = new Date();\n\n  try {\n    const res = await waku.store.queryHistory([ChatContentTopic], {\n      pageSize: 5,\n      direction: Direction.FORWARD,\n      timeFilter: {\n        startTime,\n        endTime,\n      },\n      callback,\n    });\n\n    return res.length;\n  } catch {\n    console.log('Failed to retrieve messages');\n    return 0;\n  }\n}\n\nexport default function App() {\n  const [messages, dispatchMessages] = useReducer(reduceMessages, []);\n  const [waku, setWaku] = useState<Waku | undefined>(undefined);\n  const [nick, setNick] = useState<string>(() => {\n    const persistedNick = window.localStorage.getItem('nick');\n    return persistedNick !== null ? persistedNick : generate();\n  });\n  const [\n    historicalMessagesRetrieved,\n    setHistoricalMessagesRetrieved,\n  ] = useState(false);\n\n  useEffect(() => {\n    localStorage.setItem('nick', nick);\n  }, [nick]);\n\n  useEffect(() => {\n    initWaku(setWaku)\n      .then(() => console.log('Waku init done'))\n      .catch((e) => console.log('Waku init failed ', e));\n  }, []);\n\n  useEffect(() => {\n    if (!waku) return;\n    // Let's retrieve previous messages before listening to new messages\n    if (!historicalMessagesRetrieved) return;\n\n    const handleRelayMessage = (wakuMsg: WakuMessage) => {\n      console.log('Message received: ', wakuMsg);\n      const msg = Message.fromWakuMessage(wakuMsg);\n      if (msg) {\n        dispatchMessages([msg]);\n      }\n    };\n\n    waku.relay.addObserver(handleRelayMessage, [ChatContentTopic]);\n\n    return function cleanUp() {\n      waku?.relay.deleteObserver(handleRelayMessage, [ChatContentTopic]);\n    };\n  }, [waku, historicalMessagesRetrieved]);\n\n  useEffect(() => {\n    if (!waku) return;\n    if (historicalMessagesRetrieved) return;\n\n    const checkAndRetrieve = ({ protocols }: { protocols: string[] }) => {\n      if (protocols.includes(StoreCodec)) {\n        console.log(`Retrieving archived messages}`);\n        setHistoricalMessagesRetrieved(true);\n\n        try {\n          retrieveStoreMessages(waku, dispatchMessages).then((length) =>\n            console.log(`Messages retrieved:`, length)\n          );\n        } catch (e) {\n          console.log(`Error encountered when retrieving archived messages`, e);\n        }\n      }\n    };\n\n    waku.libp2p.peerStore.on('change:protocols', checkAndRetrieve);\n\n    return () => {\n      waku.libp2p.peerStore.removeListener(\n        'change:protocols',\n        checkAndRetrieve\n      );\n    };\n  }, [waku, historicalMessagesRetrieved]);\n\n  return (\n    <div\n      className=\"chat-app\"\n      style={{ height: '100vh', width: '100vw', overflow: 'hidden' }}\n    >\n      <WakuContext.Provider value={{ waku: waku }}>\n        <ThemeProvider theme={themes}>\n          <Room\n            nick={nick}\n            messages={messages}\n            commandHandler={(input: string) => {\n              const { command, response } = handleCommand(input, waku, setNick);\n              const commandMessages = response.map((msg) => {\n                return Message.fromUtf8String(command, msg);\n              });\n              dispatchMessages(commandMessages);\n            }}\n          />\n        </ThemeProvider>\n      </WakuContext.Provider>\n    </div>\n  );\n}\n\nasync function initWaku(setter: (waku: Waku) => void) {\n  try {\n    const waku = await Waku.create({\n      libp2p: {\n        config: {\n          pubsub: {\n            enabled: true,\n            emitSelf: true,\n          },\n        },\n      },\n      bootstrap: getBootstrapNodes.bind({}, selectFleetEnv()),\n    });\n\n    setter(waku);\n  } catch (e) {\n    console.log('Issue starting waku ', e);\n  }\n}\n\nfunction selectFleetEnv() {\n  // Works with react-scripts\n  if (process?.env?.NODE_ENV === 'development') {\n    return ['fleets', 'wakuv2.test', 'waku-websocket'];\n  } else {\n    return ['fleets', 'wakuv2.prod', 'waku-websocket'];\n  }\n}\n\nfunction reduceMessages(state: Message[], newMessages: Message[]) {\n  return state.concat(newMessages);\n}\n","import { WakuMessage } from 'js-waku';\nimport { ChatMessage } from './chat_message';\n\nexport class Message {\n  public chatMessage: ChatMessage;\n  // WakuMessage timestamp\n  public sentTimestamp: Date | undefined;\n\n  constructor(chatMessage: ChatMessage, sentTimestamp: Date | undefined) {\n    this.chatMessage = chatMessage;\n    this.sentTimestamp = sentTimestamp;\n  }\n\n  static fromWakuMessage(wakuMsg: WakuMessage): Message | undefined {\n    if (wakuMsg.payload) {\n      try {\n        const chatMsg = ChatMessage.decode(wakuMsg.payload);\n        if (chatMsg) {\n          return new Message(chatMsg, wakuMsg.timestamp);\n        }\n      } catch (e) {\n        console.error(\n          'Failed to decode chat message',\n          wakuMsg.payloadAsUtf8,\n          e\n        );\n      }\n    }\n    return;\n  }\n\n  static fromUtf8String(nick: string, text: string): Message {\n    const now = new Date();\n    return new Message(ChatMessage.fromUtf8String(now, nick, text), now);\n  }\n\n  get nick() {\n    return this.chatMessage.nick;\n  }\n\n  get timestamp() {\n    return this.chatMessage.timestamp;\n  }\n\n  get payloadAsUtf8() {\n    return this.chatMessage.payloadAsUtf8;\n  }\n}\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.symmetric = exports.TagSize = exports.IvSize = exports.SymmetricKeySize = void 0;\nexports.SymmetricKeySize = 32;\nexports.IvSize = 12;\nexports.TagSize = 16;\nexports.symmetric = {};\nPromise.resolve().then(() => __importStar(require('./browser'))).then((mod) => {\n    exports.symmetric = mod;\n})\n    .catch((eBrowser) => {\n    Promise.resolve().then(() => __importStar(require('./node'))).then((mod) => {\n        exports.symmetric = mod;\n    })\n        .catch((eNode) => {\n        throw `Could not load any symmetric crypto modules: ${eBrowser}, ${eNode}`;\n    });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuRelay = exports.RelayCodecs = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst libp2p_gossipsub_1 = __importDefault(require(\"libp2p-gossipsub\"));\nconst utils_1 = require(\"libp2p-gossipsub/src/utils\");\nconst signature_policy_1 = require(\"libp2p-interfaces/src/pubsub/signature-policy\");\nconst peer_id_1 = __importDefault(require(\"peer-id\"));\nconst waku_1 = require(\"../waku\");\nconst waku_message_1 = require(\"../waku_message\");\nconst constants = __importStar(require(\"./constants\"));\nconst constants_1 = require(\"./constants\");\nObject.defineProperty(exports, \"RelayCodecs\", { enumerable: true, get: function () { return constants_1.RelayCodecs; } });\nconst get_relay_peers_1 = require(\"./get_relay_peers\");\nconst relay_heartbeat_1 = require(\"./relay_heartbeat\");\nconst dbg = debug_1.default('waku:relay');\n/**\n * Implements the [Waku v2 Relay protocol]{@link https://rfc.vac.dev/spec/11/}.\n * Must be passed as a `pubsub` module to a {Libp2p} instance.\n *\n * @implements {require('libp2p-interfaces/src/pubsub')}\n * @noInheritDoc\n */\nclass WakuRelay extends libp2p_gossipsub_1.default {\n    constructor(libp2p, options) {\n        super(libp2p, Object.assign(options, {\n            // Ensure that no signature is included nor expected in the messages.\n            globalSignaturePolicy: signature_policy_1.SignaturePolicy.StrictNoSign,\n        }));\n        this.heartbeat = new relay_heartbeat_1.RelayHeartbeat(this);\n        this.observers = {};\n        this.decryptionKeys = new Set();\n        const multicodecs = constants.RelayCodecs;\n        Object.assign(this, { multicodecs });\n        this.pubSubTopic = (options === null || options === void 0 ? void 0 : options.pubSubTopic) || waku_1.DefaultPubSubTopic;\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node\n     * and subscribes to the default topic.\n     *\n     * @override\n     * @returns {void}\n     */\n    start() {\n        super.start();\n        this.subscribe(this.pubSubTopic);\n    }\n    /**\n     * Send Waku message.\n     *\n     * @param {WakuMessage} message\n     * @returns {Promise<void>}\n     */\n    async send(message) {\n        const msg = message.encode();\n        await super.publish(this.pubSubTopic, Buffer.from(msg));\n    }\n    /**\n     * Register a decryption private key or symmetric key to attempt decryption\n     * of messages received on the given content topic. This can either be a\n     * private key for asymmetric encryption or a symmetric key. Waku relay will\n     * attempt to decrypt messages using both methods.\n     */\n    addDecryptionKey(privateKey) {\n        this.decryptionKeys.add(privateKey);\n    }\n    /**\n     * Delete a decryption key to attempt decryption of messages received on the\n     * given content topic.\n     */\n    deleteDecryptionKey(privateKey) {\n        this.decryptionKeys.delete(privateKey);\n    }\n    /**\n     * Register an observer of new messages received via waku relay\n     *\n     * @param callback called when a new message is received via waku relay\n     * @param contentTopics Content Topics for which the callback with be called,\n     * all of them if undefined, [] or [\"\",..] is passed.\n     * @returns {void}\n     */\n    addObserver(callback, contentTopics = []) {\n        if (contentTopics.length === 0) {\n            if (!this.observers['']) {\n                this.observers[''] = new Set();\n            }\n            this.observers[''].add(callback);\n        }\n        else {\n            contentTopics.forEach((contentTopic) => {\n                if (!this.observers[contentTopic]) {\n                    this.observers[contentTopic] = new Set();\n                }\n                this.observers[contentTopic].add(callback);\n            });\n        }\n    }\n    /**\n     * Remove an observer of new messages received via waku relay.\n     * Useful to ensure the same observer is not registered several time\n     * (e.g when loading React components)\n     */\n    deleteObserver(callback, contentTopics = []) {\n        if (contentTopics.length === 0) {\n            if (this.observers['']) {\n                this.observers[''].delete(callback);\n            }\n        }\n        else {\n            contentTopics.forEach((contentTopic) => {\n                if (this.observers[contentTopic]) {\n                    this.observers[contentTopic].delete(callback);\n                }\n            });\n        }\n    }\n    /**\n     * Return the relay peers we are connected to and we would publish a message to\n     */\n    getPeers() {\n        return get_relay_peers_1.getRelayPeers(this, this.pubSubTopic, this._options.D, (id) => {\n            // Filter peers we would not publish to\n            return (this.score.score(id) >= this._options.scoreThresholds.publishThreshold);\n        });\n    }\n    /**\n     * Subscribe to a pubsub topic and start emitting Waku messages to observers.\n     *\n     * @override\n     */\n    subscribe(pubSubTopic) {\n        this.on(pubSubTopic, (event) => {\n            dbg(`Message received on ${pubSubTopic}`);\n            waku_message_1.WakuMessage.decode(event.data, Array.from(this.decryptionKeys))\n                .then((wakuMsg) => {\n                if (!wakuMsg) {\n                    dbg('Failed to decode Waku Message');\n                    return;\n                }\n                if (this.observers['']) {\n                    this.observers[''].forEach((callbackFn) => {\n                        callbackFn(wakuMsg);\n                    });\n                }\n                if (wakuMsg.contentTopic) {\n                    if (this.observers[wakuMsg.contentTopic]) {\n                        this.observers[wakuMsg.contentTopic].forEach((callbackFn) => {\n                            callbackFn(wakuMsg);\n                        });\n                    }\n                }\n            })\n                .catch((e) => {\n                dbg('Failed to decode Waku Message', e);\n            });\n        });\n        super.subscribe(pubSubTopic);\n    }\n    /**\n     * Join pubsub topic.\n     * This is present to override the behavior of Gossipsub and should not\n     * be used by API Consumers\n     *\n     * @internal\n     * @param {string} topic\n     * @returns {void}\n     * @override\n     */\n    join(topic) {\n        var _a;\n        if (!this.started) {\n            throw new Error('WakuRelayPubSub has not started');\n        }\n        const fanoutPeers = this.fanout.get(topic);\n        if (fanoutPeers) {\n            // these peers have a score above the publish threshold, which may be negative\n            // so drop the ones with a negative score\n            fanoutPeers.forEach((id) => {\n                if (this.score.score(id) < 0) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            if (fanoutPeers.size < this._options.D) {\n                // we need more peers; eager, as this would get fixed in the next heartbeat\n                get_relay_peers_1.getRelayPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {\n                    // filter our current peers, direct peers, and peers with negative scores\n                    return (!fanoutPeers.has(id) &&\n                        !this.direct.has(id) &&\n                        this.score.score(id) >= 0);\n                }).forEach((id) => fanoutPeers.add(id));\n            }\n            this.mesh.set(topic, fanoutPeers);\n            this.fanout.delete(topic);\n            this.lastpub.delete(topic);\n        }\n        else {\n            const peers = get_relay_peers_1.getRelayPeers(this, topic, this._options.D, (id) => {\n                // filter direct peers and peers with negative score\n                return !this.direct.has(id) && this.score.score(id) >= 0;\n            });\n            this.mesh.set(topic, peers);\n        }\n        (_a = this.mesh.get(topic)) === null || _a === void 0 ? void 0 : _a.forEach((id) => {\n            this.log('JOIN: Add mesh link to %s in %s', id, topic);\n            this._sendGraft(id, topic);\n        });\n    }\n    /**\n     * Publish messages.\n     * This is present to override the behavior of Gossipsub and should not\n     * be used by API Consumers\n     *\n     * @ignore\n     * @override\n     * @param {InMessage} msg\n     * @returns {void}\n     */\n    async _publish(msg) {\n        if (msg.receivedFrom !== this.peerId.toB58String()) {\n            this.score.deliverMessage(msg);\n            this.gossipTracer.deliverMessage(msg);\n        }\n        const msgID = this.getMsgId(msg);\n        const msgIdStr = utils_1.messageIdToString(msgID);\n        // put in seen cache\n        this.seenCache.put(msgIdStr);\n        this.messageCache.put(msg);\n        const toSend = new Set();\n        msg.topicIDs.forEach((topic) => {\n            const peersInTopic = this.topics.get(topic);\n            if (!peersInTopic) {\n                return;\n            }\n            // direct peers\n            this.direct.forEach((id) => {\n                toSend.add(id);\n            });\n            let meshPeers = this.mesh.get(topic);\n            if (!meshPeers || !meshPeers.size) {\n                // We are not in the mesh for topic, use fanout peers\n                meshPeers = this.fanout.get(topic);\n                if (!meshPeers) {\n                    // If we are not in the fanout, then pick peers in topic above the publishThreshold\n                    const peers = get_relay_peers_1.getRelayPeers(this, topic, this._options.D, (id) => {\n                        return (this.score.score(id) >=\n                            this._options.scoreThresholds.publishThreshold);\n                    });\n                    if (peers.size > 0) {\n                        meshPeers = peers;\n                        this.fanout.set(topic, peers);\n                    }\n                    else {\n                        meshPeers = new Set();\n                    }\n                }\n                // Store the latest publishing time\n                this.lastpub.set(topic, this._now());\n            }\n            meshPeers === null || meshPeers === void 0 ? void 0 : meshPeers.forEach((peer) => {\n                toSend.add(peer);\n            });\n        });\n        // Publish messages to peers\n        const rpc = utils_1.createGossipRpc([libp2p_gossipsub_1.default.utils.normalizeOutRpcMessage(msg)]);\n        toSend.forEach((id) => {\n            if (id === msg.from) {\n                return;\n            }\n            this._sendRpc(id, rpc);\n        });\n    }\n    /**\n     * Emits gossip to peers in a particular topic.\n     *\n     * This is present to override the behavior of Gossipsub and should not\n     * be used by API Consumers\n     *\n     * @ignore\n     * @override\n     * @param {string} topic\n     * @param {Set<string>} exclude peers to exclude\n     * @returns {void}\n     */\n    _emitGossip(topic, exclude) {\n        const messageIDs = this.messageCache.getGossipIDs(topic);\n        if (!messageIDs.length) {\n            return;\n        }\n        // shuffle to emit in random order\n        utils_1.shuffle(messageIDs);\n        // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n        if (messageIDs.length > constants.RelayMaxIHaveLength) {\n            // we do the truncation (with shuffling) per peer below\n            this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length);\n        }\n        // Send gossip to GossipFactor peers above threshold with a minimum of D_lazy\n        // First we collect the peers above gossipThreshold that are not in the exclude set\n        // and then randomly select from that set\n        // We also exclude direct peers, as there is no reason to emit gossip to them\n        const peersToGossip = [];\n        const topicPeers = this.topics.get(topic);\n        if (!topicPeers) {\n            // no topic peers, no gossip\n            return;\n        }\n        topicPeers.forEach((id) => {\n            const peerStreams = this.peers.get(id);\n            if (!peerStreams) {\n                return;\n            }\n            if (!exclude.has(id) &&\n                !this.direct.has(id) &&\n                constants.RelayCodecs.includes(peerStreams.protocol) &&\n                this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {\n                peersToGossip.push(id);\n            }\n        });\n        let target = this._options.Dlazy;\n        const factor = constants.RelayGossipFactor * peersToGossip.length;\n        if (factor > target) {\n            target = factor;\n        }\n        if (target > peersToGossip.length) {\n            target = peersToGossip.length;\n        }\n        else {\n            utils_1.shuffle(peersToGossip);\n        }\n        // Emit the IHAVE gossip to the selected peers up to the target\n        peersToGossip.slice(0, target).forEach((id) => {\n            let peerMessageIDs = messageIDs;\n            if (messageIDs.length > constants.RelayMaxIHaveLength) {\n                // shuffle and slice message IDs per peer so that we emit a different set for each peer\n                // we have enough redundancy in the system that this will significantly increase the message\n                // coverage when we do truncate\n                peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.RelayMaxIHaveLength);\n            }\n            this._pushGossip(id, {\n                topicID: topic,\n                messageIDs: peerMessageIDs,\n            });\n        });\n    }\n    /**\n     * Make a PRUNE control message for a peer in a topic.\n     * This is present to override the behavior of Gossipsub and should not\n     * be used by API Consumers\n     *\n     * @ignore\n     * @override\n     * @param {string} id\n     * @param {string} topic\n     * @param {boolean} doPX\n     * @returns {RPC.IControlPrune}\n     */\n    _makePrune(id, topic, doPX) {\n        // backoff is measured in seconds\n        // RelayPruneBackoff is measured in milliseconds\n        const backoff = constants.RelayPruneBackoff / 1000;\n        const px = [];\n        if (doPX) {\n            // select peers for Peer eXchange\n            const peers = get_relay_peers_1.getRelayPeers(this, topic, constants.RelayPrunePeers, (xid) => {\n                return xid !== id && this.score.score(xid) >= 0;\n            });\n            peers.forEach((p) => {\n                // see if we have a signed record to send back; if we don't, just send\n                // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n                // unsigned address records through PX anyways\n                // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n                const peerId = peer_id_1.default.createFromB58String(p);\n                px.push({\n                    peerID: peerId.toBytes(),\n                    signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId),\n                });\n            });\n        }\n        return {\n            topicID: topic,\n            peers: px,\n            backoff: backoff,\n        };\n    }\n}\nexports.WakuRelay = WakuRelay;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo = exports.Index = exports.historyResponse_ErrorToJSON = exports.historyResponse_ErrorFromJSON = exports.HistoryResponse_Error = exports.pagingInfo_DirectionToJSON = exports.pagingInfo_DirectionFromJSON = exports.PagingInfo_Direction = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst message_1 = require(\"../../waku/v2/message\");\nexports.protobufPackage = 'waku.v2';\nvar PagingInfo_Direction;\n(function (PagingInfo_Direction) {\n    PagingInfo_Direction[PagingInfo_Direction[\"DIRECTION_BACKWARD_UNSPECIFIED\"] = 0] = \"DIRECTION_BACKWARD_UNSPECIFIED\";\n    PagingInfo_Direction[PagingInfo_Direction[\"DIRECTION_FORWARD\"] = 1] = \"DIRECTION_FORWARD\";\n    PagingInfo_Direction[PagingInfo_Direction[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(PagingInfo_Direction = exports.PagingInfo_Direction || (exports.PagingInfo_Direction = {}));\nfunction pagingInfo_DirectionFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'DIRECTION_BACKWARD_UNSPECIFIED':\n            return PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;\n        case 1:\n        case 'DIRECTION_FORWARD':\n            return PagingInfo_Direction.DIRECTION_FORWARD;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return PagingInfo_Direction.UNRECOGNIZED;\n    }\n}\nexports.pagingInfo_DirectionFromJSON = pagingInfo_DirectionFromJSON;\nfunction pagingInfo_DirectionToJSON(object) {\n    switch (object) {\n        case PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED:\n            return 'DIRECTION_BACKWARD_UNSPECIFIED';\n        case PagingInfo_Direction.DIRECTION_FORWARD:\n            return 'DIRECTION_FORWARD';\n        default:\n            return 'UNKNOWN';\n    }\n}\nexports.pagingInfo_DirectionToJSON = pagingInfo_DirectionToJSON;\nvar HistoryResponse_Error;\n(function (HistoryResponse_Error) {\n    HistoryResponse_Error[HistoryResponse_Error[\"ERROR_NONE_UNSPECIFIED\"] = 0] = \"ERROR_NONE_UNSPECIFIED\";\n    HistoryResponse_Error[HistoryResponse_Error[\"ERROR_INVALID_CURSOR\"] = 1] = \"ERROR_INVALID_CURSOR\";\n    HistoryResponse_Error[HistoryResponse_Error[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(HistoryResponse_Error = exports.HistoryResponse_Error || (exports.HistoryResponse_Error = {}));\nfunction historyResponse_ErrorFromJSON(object) {\n    switch (object) {\n        case 0:\n        case 'ERROR_NONE_UNSPECIFIED':\n            return HistoryResponse_Error.ERROR_NONE_UNSPECIFIED;\n        case 1:\n        case 'ERROR_INVALID_CURSOR':\n            return HistoryResponse_Error.ERROR_INVALID_CURSOR;\n        case -1:\n        case 'UNRECOGNIZED':\n        default:\n            return HistoryResponse_Error.UNRECOGNIZED;\n    }\n}\nexports.historyResponse_ErrorFromJSON = historyResponse_ErrorFromJSON;\nfunction historyResponse_ErrorToJSON(object) {\n    switch (object) {\n        case HistoryResponse_Error.ERROR_NONE_UNSPECIFIED:\n            return 'ERROR_NONE_UNSPECIFIED';\n        case HistoryResponse_Error.ERROR_INVALID_CURSOR:\n            return 'ERROR_INVALID_CURSOR';\n        default:\n            return 'UNKNOWN';\n    }\n}\nexports.historyResponse_ErrorToJSON = historyResponse_ErrorToJSON;\nconst baseIndex = { receivedTime: 0, senderTime: 0 };\nexports.Index = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.digest.length !== 0) {\n            writer.uint32(10).bytes(message.digest);\n        }\n        if (message.receivedTime !== 0) {\n            writer.uint32(17).double(message.receivedTime);\n        }\n        if (message.senderTime !== 0) {\n            writer.uint32(25).double(message.senderTime);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseIndex);\n        message.digest = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.digest = reader.bytes();\n                    break;\n                case 2:\n                    message.receivedTime = reader.double();\n                    break;\n                case 3:\n                    message.senderTime = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseIndex);\n        message.digest = new Uint8Array();\n        if (object.digest !== undefined && object.digest !== null) {\n            message.digest = bytesFromBase64(object.digest);\n        }\n        if (object.receivedTime !== undefined && object.receivedTime !== null) {\n            message.receivedTime = Number(object.receivedTime);\n        }\n        else {\n            message.receivedTime = 0;\n        }\n        if (object.senderTime !== undefined && object.senderTime !== null) {\n            message.senderTime = Number(object.senderTime);\n        }\n        else {\n            message.senderTime = 0;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.digest !== undefined &&\n            (obj.digest = base64FromBytes(message.digest !== undefined ? message.digest : new Uint8Array()));\n        message.receivedTime !== undefined &&\n            (obj.receivedTime = message.receivedTime);\n        message.senderTime !== undefined && (obj.senderTime = message.senderTime);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseIndex);\n        if (object.digest !== undefined && object.digest !== null) {\n            message.digest = object.digest;\n        }\n        else {\n            message.digest = new Uint8Array();\n        }\n        if (object.receivedTime !== undefined && object.receivedTime !== null) {\n            message.receivedTime = object.receivedTime;\n        }\n        else {\n            message.receivedTime = 0;\n        }\n        if (object.senderTime !== undefined && object.senderTime !== null) {\n            message.senderTime = object.senderTime;\n        }\n        else {\n            message.senderTime = 0;\n        }\n        return message;\n    },\n};\nconst basePagingInfo = { pageSize: 0, direction: 0 };\nexports.PagingInfo = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pageSize !== 0) {\n            writer.uint32(8).uint64(message.pageSize);\n        }\n        if (message.cursor !== undefined) {\n            exports.Index.encode(message.cursor, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.direction !== 0) {\n            writer.uint32(24).int32(message.direction);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, basePagingInfo);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pageSize = longToNumber(reader.uint64());\n                    break;\n                case 2:\n                    message.cursor = exports.Index.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.direction = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, basePagingInfo);\n        if (object.pageSize !== undefined && object.pageSize !== null) {\n            message.pageSize = Number(object.pageSize);\n        }\n        else {\n            message.pageSize = 0;\n        }\n        if (object.cursor !== undefined && object.cursor !== null) {\n            message.cursor = exports.Index.fromJSON(object.cursor);\n        }\n        else {\n            message.cursor = undefined;\n        }\n        if (object.direction !== undefined && object.direction !== null) {\n            message.direction = pagingInfo_DirectionFromJSON(object.direction);\n        }\n        else {\n            message.direction = 0;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pageSize !== undefined && (obj.pageSize = message.pageSize);\n        message.cursor !== undefined &&\n            (obj.cursor = message.cursor ? exports.Index.toJSON(message.cursor) : undefined);\n        message.direction !== undefined &&\n            (obj.direction = pagingInfo_DirectionToJSON(message.direction));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, basePagingInfo);\n        if (object.pageSize !== undefined && object.pageSize !== null) {\n            message.pageSize = object.pageSize;\n        }\n        else {\n            message.pageSize = 0;\n        }\n        if (object.cursor !== undefined && object.cursor !== null) {\n            message.cursor = exports.Index.fromPartial(object.cursor);\n        }\n        else {\n            message.cursor = undefined;\n        }\n        if (object.direction !== undefined && object.direction !== null) {\n            message.direction = object.direction;\n        }\n        else {\n            message.direction = 0;\n        }\n        return message;\n    },\n};\nconst baseContentFilter = { contentTopic: '' };\nexports.ContentFilter = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.contentTopic !== '') {\n            writer.uint32(10).string(message.contentTopic);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseContentFilter);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.contentTopic = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseContentFilter);\n        if (object.contentTopic !== undefined && object.contentTopic !== null) {\n            message.contentTopic = String(object.contentTopic);\n        }\n        else {\n            message.contentTopic = '';\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.contentTopic !== undefined &&\n            (obj.contentTopic = message.contentTopic);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseContentFilter);\n        if (object.contentTopic !== undefined && object.contentTopic !== null) {\n            message.contentTopic = object.contentTopic;\n        }\n        else {\n            message.contentTopic = '';\n        }\n        return message;\n    },\n};\nconst baseHistoryQuery = {};\nexports.HistoryQuery = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pubSubTopic !== undefined) {\n            writer.uint32(18).string(message.pubSubTopic);\n        }\n        for (const v of message.contentFilters) {\n            exports.ContentFilter.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.pagingInfo !== undefined) {\n            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.startTime !== undefined) {\n            writer.uint32(41).double(message.startTime);\n        }\n        if (message.endTime !== undefined) {\n            writer.uint32(49).double(message.endTime);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseHistoryQuery);\n        message.contentFilters = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    message.pubSubTopic = reader.string();\n                    break;\n                case 3:\n                    message.contentFilters.push(exports.ContentFilter.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.startTime = reader.double();\n                    break;\n                case 6:\n                    message.endTime = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseHistoryQuery);\n        message.contentFilters = [];\n        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {\n            message.pubSubTopic = String(object.pubSubTopic);\n        }\n        else {\n            message.pubSubTopic = undefined;\n        }\n        if (object.contentFilters !== undefined && object.contentFilters !== null) {\n            for (const e of object.contentFilters) {\n                message.contentFilters.push(exports.ContentFilter.fromJSON(e));\n            }\n        }\n        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {\n            message.pagingInfo = exports.PagingInfo.fromJSON(object.pagingInfo);\n        }\n        else {\n            message.pagingInfo = undefined;\n        }\n        if (object.startTime !== undefined && object.startTime !== null) {\n            message.startTime = Number(object.startTime);\n        }\n        else {\n            message.startTime = undefined;\n        }\n        if (object.endTime !== undefined && object.endTime !== null) {\n            message.endTime = Number(object.endTime);\n        }\n        else {\n            message.endTime = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pubSubTopic !== undefined &&\n            (obj.pubSubTopic = message.pubSubTopic);\n        if (message.contentFilters) {\n            obj.contentFilters = message.contentFilters.map((e) => e ? exports.ContentFilter.toJSON(e) : undefined);\n        }\n        else {\n            obj.contentFilters = [];\n        }\n        message.pagingInfo !== undefined &&\n            (obj.pagingInfo = message.pagingInfo\n                ? exports.PagingInfo.toJSON(message.pagingInfo)\n                : undefined);\n        message.startTime !== undefined && (obj.startTime = message.startTime);\n        message.endTime !== undefined && (obj.endTime = message.endTime);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseHistoryQuery);\n        message.contentFilters = [];\n        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {\n            message.pubSubTopic = object.pubSubTopic;\n        }\n        else {\n            message.pubSubTopic = undefined;\n        }\n        if (object.contentFilters !== undefined && object.contentFilters !== null) {\n            for (const e of object.contentFilters) {\n                message.contentFilters.push(exports.ContentFilter.fromPartial(e));\n            }\n        }\n        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {\n            message.pagingInfo = exports.PagingInfo.fromPartial(object.pagingInfo);\n        }\n        else {\n            message.pagingInfo = undefined;\n        }\n        if (object.startTime !== undefined && object.startTime !== null) {\n            message.startTime = object.startTime;\n        }\n        else {\n            message.startTime = undefined;\n        }\n        if (object.endTime !== undefined && object.endTime !== null) {\n            message.endTime = object.endTime;\n        }\n        else {\n            message.endTime = undefined;\n        }\n        return message;\n    },\n};\nconst baseHistoryResponse = { error: 0 };\nexports.HistoryResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        for (const v of message.messages) {\n            message_1.WakuMessage.encode(v, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.pagingInfo !== undefined) {\n            exports.PagingInfo.encode(message.pagingInfo, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.error !== 0) {\n            writer.uint32(32).int32(message.error);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseHistoryResponse);\n        message.messages = [];\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    message.messages.push(message_1.WakuMessage.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.pagingInfo = exports.PagingInfo.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.error = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseHistoryResponse);\n        message.messages = [];\n        if (object.messages !== undefined && object.messages !== null) {\n            for (const e of object.messages) {\n                message.messages.push(message_1.WakuMessage.fromJSON(e));\n            }\n        }\n        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {\n            message.pagingInfo = exports.PagingInfo.fromJSON(object.pagingInfo);\n        }\n        else {\n            message.pagingInfo = undefined;\n        }\n        if (object.error !== undefined && object.error !== null) {\n            message.error = historyResponse_ErrorFromJSON(object.error);\n        }\n        else {\n            message.error = 0;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.messages) {\n            obj.messages = message.messages.map((e) => e ? message_1.WakuMessage.toJSON(e) : undefined);\n        }\n        else {\n            obj.messages = [];\n        }\n        message.pagingInfo !== undefined &&\n            (obj.pagingInfo = message.pagingInfo\n                ? exports.PagingInfo.toJSON(message.pagingInfo)\n                : undefined);\n        message.error !== undefined &&\n            (obj.error = historyResponse_ErrorToJSON(message.error));\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseHistoryResponse);\n        message.messages = [];\n        if (object.messages !== undefined && object.messages !== null) {\n            for (const e of object.messages) {\n                message.messages.push(message_1.WakuMessage.fromPartial(e));\n            }\n        }\n        if (object.pagingInfo !== undefined && object.pagingInfo !== null) {\n            message.pagingInfo = exports.PagingInfo.fromPartial(object.pagingInfo);\n        }\n        else {\n            message.pagingInfo = undefined;\n        }\n        if (object.error !== undefined && object.error !== null) {\n            message.error = object.error;\n        }\n        else {\n            message.error = 0;\n        }\n        return message;\n    },\n};\nconst baseHistoryRPC = { requestId: '' };\nexports.HistoryRPC = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.requestId !== '') {\n            writer.uint32(10).string(message.requestId);\n        }\n        if (message.query !== undefined) {\n            exports.HistoryQuery.encode(message.query, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.response !== undefined) {\n            exports.HistoryResponse.encode(message.response, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseHistoryRPC);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.string();\n                    break;\n                case 2:\n                    message.query = exports.HistoryQuery.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.response = exports.HistoryResponse.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseHistoryRPC);\n        if (object.requestId !== undefined && object.requestId !== null) {\n            message.requestId = String(object.requestId);\n        }\n        else {\n            message.requestId = '';\n        }\n        if (object.query !== undefined && object.query !== null) {\n            message.query = exports.HistoryQuery.fromJSON(object.query);\n        }\n        else {\n            message.query = undefined;\n        }\n        if (object.response !== undefined && object.response !== null) {\n            message.response = exports.HistoryResponse.fromJSON(object.response);\n        }\n        else {\n            message.response = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.requestId !== undefined && (obj.requestId = message.requestId);\n        message.query !== undefined &&\n            (obj.query = message.query\n                ? exports.HistoryQuery.toJSON(message.query)\n                : undefined);\n        message.response !== undefined &&\n            (obj.response = message.response\n                ? exports.HistoryResponse.toJSON(message.response)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseHistoryRPC);\n        if (object.requestId !== undefined && object.requestId !== null) {\n            message.requestId = object.requestId;\n        }\n        else {\n            message.requestId = '';\n        }\n        if (object.query !== undefined && object.query !== null) {\n            message.query = exports.HistoryQuery.fromPartial(object.query);\n        }\n        else {\n            message.query = undefined;\n        }\n        if (object.response !== undefined && object.response !== null) {\n            message.response = exports.HistoryResponse.fromPartial(object.response);\n        }\n        else {\n            message.response = undefined;\n        }\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== 'undefined')\n        return globalThis;\n    if (typeof self !== 'undefined')\n        return self;\n    if (typeof window !== 'undefined')\n        return window;\n    if (typeof global !== 'undefined')\n        return global;\n    throw 'Unable to locate global object';\n})();\nconst atob = globalThis.atob ||\n    ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa ||\n    ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (const byte of arr) {\n        bin.push(String.fromCharCode(byte));\n    }\n    return btoa(bin.join(''));\n}\nfunction longToNumber(long) {\n    if (long.gt(Number.MAX_SAFE_INTEGER)) {\n        throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');\n    }\n    return long.toNumber();\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=store.js.map","/* eslint-disable */\nimport Long from 'long';\nimport _m0 from 'protobufjs/minimal';\n\nexport const protobufPackage = '';\n\nexport interface ChatMessage {\n  timestamp: number;\n  nick: string;\n  payload: Uint8Array;\n}\n\nconst baseChatMessage: object = { timestamp: 0, nick: '' };\n\nexport const ChatMessage = {\n  encode(\n    message: ChatMessage,\n    writer: _m0.Writer = _m0.Writer.create()\n  ): _m0.Writer {\n    if (message.timestamp !== 0) {\n      writer.uint32(8).uint64(message.timestamp);\n    }\n    if (message.nick !== '') {\n      writer.uint32(18).string(message.nick);\n    }\n    if (message.payload.length !== 0) {\n      writer.uint32(26).bytes(message.payload);\n    }\n    return writer;\n  },\n\n  decode(input: _m0.Reader | Uint8Array, length?: number): ChatMessage {\n    const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = { ...baseChatMessage } as ChatMessage;\n    message.payload = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.timestamp = longToNumber(reader.uint64() as Long);\n          break;\n        case 2:\n          message.nick = reader.string();\n          break;\n        case 3:\n          message.payload = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ChatMessage {\n    const message = { ...baseChatMessage } as ChatMessage;\n    message.payload = new Uint8Array();\n    if (object.timestamp !== undefined && object.timestamp !== null) {\n      message.timestamp = Number(object.timestamp);\n    } else {\n      message.timestamp = 0;\n    }\n    if (object.nick !== undefined && object.nick !== null) {\n      message.nick = String(object.nick);\n    } else {\n      message.nick = '';\n    }\n    if (object.payload !== undefined && object.payload !== null) {\n      message.payload = bytesFromBase64(object.payload);\n    }\n    return message;\n  },\n\n  toJSON(message: ChatMessage): unknown {\n    const obj: any = {};\n    message.timestamp !== undefined && (obj.timestamp = message.timestamp);\n    message.nick !== undefined && (obj.nick = message.nick);\n    message.payload !== undefined &&\n      (obj.payload = base64FromBytes(\n        message.payload !== undefined ? message.payload : new Uint8Array()\n      ));\n    return obj;\n  },\n\n  fromPartial(object: DeepPartial<ChatMessage>): ChatMessage {\n    const message = { ...baseChatMessage } as ChatMessage;\n    if (object.timestamp !== undefined && object.timestamp !== null) {\n      message.timestamp = object.timestamp;\n    } else {\n      message.timestamp = 0;\n    }\n    if (object.nick !== undefined && object.nick !== null) {\n      message.nick = object.nick;\n    } else {\n      message.nick = '';\n    }\n    if (object.payload !== undefined && object.payload !== null) {\n      message.payload = object.payload;\n    } else {\n      message.payload = new Uint8Array();\n    }\n    return message;\n  },\n};\n\ndeclare var self: any | undefined;\ndeclare var window: any | undefined;\nvar globalThis: any = (() => {\n  if (typeof globalThis !== 'undefined') return globalThis;\n  if (typeof self !== 'undefined') return self;\n  if (typeof window !== 'undefined') return window;\n  if (typeof global !== 'undefined') return global;\n  throw 'Unable to locate global object';\n})();\n\nconst atob: (b64: string) => string =\n  globalThis.atob ||\n  ((b64) => globalThis.Buffer.from(b64, 'base64').toString('binary'));\nfunction bytesFromBase64(b64: string): Uint8Array {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\n\nconst btoa: (bin: string) => string =\n  globalThis.btoa ||\n  ((bin) => globalThis.Buffer.from(bin, 'binary').toString('base64'));\nfunction base64FromBytes(arr: Uint8Array): string {\n  const bin: string[] = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(''));\n}\n\ntype Builtin =\n  | Date\n  | Function\n  | Uint8Array\n  | string\n  | number\n  | boolean\n  | undefined;\nexport type DeepPartial<T> = T extends Builtin\n  ? T\n  : T extends Array<infer U>\n  ? Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U>\n  ? ReadonlyArray<DeepPartial<U>>\n  : T extends {}\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\nfunction longToNumber(long: Long): number {\n  if (long.gt(Number.MAX_SAFE_INTEGER)) {\n    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER');\n  }\n  return long.toNumber();\n}\n\nif (_m0.util.Long !== Long) {\n  _m0.util.Long = Long as any;\n  _m0.configure();\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getBootstrapNodes = void 0;\nconst axios_1 = __importDefault(require(\"axios\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst dbg = debug_1.default('waku:discovery');\n/**\n * GET list of nodes from remote HTTP host.\n *\n * Default behaviour is to return nodes hosted by Status.\n *\n * @param path The property path to access the node list. The result should be\n * a string, a string array or an object. If the result is an object then the\n * values of the objects are used as multiaddresses. For example, if the GET\n * request returns `{ foo: { bar: [address1, address2] } }` then `path` should be\n * `[ \"foo\", \"bar\" ]`.\n * @param url Remote host containing bootstrap peers in JSON format.\n *\n * @returns An array of multiaddresses.\n * @throws If the remote host is unreachable or the response cannot be parsed\n * according to the passed _path_.\n */\nasync function getBootstrapNodes(path = ['fleets', 'wakuv2.prod', 'waku-websocket'], url = 'https://fleets.status.im/') {\n    const res = await axios_1.default.get(url, {\n        headers: { 'Content-Type': 'application/json' },\n    });\n    let nodes = res.data;\n    for (const prop of path) {\n        if (nodes[prop] === undefined) {\n            dbg(`Failed to retrieve bootstrap nodes: ${prop} does not exist on `, nodes);\n            throw `Failed to retrieve bootstrap nodes: ${prop} does not exist on ${JSON.stringify(nodes)}`;\n        }\n        nodes = nodes[prop];\n    }\n    if (Array.isArray(nodes)) {\n        return nodes;\n    }\n    if (typeof nodes === 'string') {\n        return [nodes];\n    }\n    if (typeof nodes === 'object') {\n        return Object.values(nodes);\n    }\n    throw `Failed to retrieve bootstrap nodes: response format is not supported: ${JSON.stringify(nodes)}`;\n}\nexports.getBootstrapNodes = getBootstrapNodes;\n//# sourceMappingURL=discovery.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.equalByteArrays = exports.bufToHex = exports.hexToBuf = void 0;\nfunction hexToBuf(hex) {\n    if (typeof hex === 'string') {\n        return Buffer.from(hex.replace(/^0x/i, ''), 'hex');\n    }\n    else {\n        return Buffer.from(hex);\n    }\n}\nexports.hexToBuf = hexToBuf;\nfunction bufToHex(buf) {\n    const _buf = Buffer.from(buf);\n    return _buf.toString('hex');\n}\nexports.bufToHex = bufToHex;\nfunction equalByteArrays(a, b) {\n    let aBuf;\n    let bBuf;\n    if (typeof a === 'string') {\n        aBuf = hexToBuf(a);\n    }\n    else {\n        aBuf = Buffer.from(a);\n    }\n    if (typeof b === 'string') {\n        bBuf = hexToBuf(b);\n    }\n    else {\n        bBuf = Buffer.from(b);\n    }\n    return aBuf.compare(bBuf) === 0;\n}\nexports.equalByteArrays = equalByteArrays;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuLightPush = exports.PushResponse = exports.LightPushCodec = void 0;\nconst it_concat_1 = __importDefault(require(\"it-concat\"));\nconst it_length_prefixed_1 = __importDefault(require(\"it-length-prefixed\"));\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\nconst light_push_1 = require(\"../../proto/waku/v2/light_push\");\nObject.defineProperty(exports, \"PushResponse\", { enumerable: true, get: function () { return light_push_1.PushResponse; } });\nconst select_peer_1 = require(\"../select_peer\");\nconst waku_1 = require(\"../waku\");\nconst push_rpc_1 = require(\"./push_rpc\");\nexports.LightPushCodec = '/vac/waku/lightpush/2.0.0-beta1';\n/**\n * Implements the [Waku v2 Light Push protocol](https://rfc.vac.dev/spec/19/).\n */\nclass WakuLightPush {\n    constructor(libp2p, options) {\n        this.libp2p = libp2p;\n        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {\n            this.pubSubTopic = options.pubSubTopic;\n        }\n        else {\n            this.pubSubTopic = waku_1.DefaultPubSubTopic;\n        }\n    }\n    async push(message, opts) {\n        let peer;\n        if (opts === null || opts === void 0 ? void 0 : opts.peerId) {\n            peer = this.libp2p.peerStore.get(opts.peerId);\n            if (!peer)\n                throw 'Peer is unknown';\n        }\n        else {\n            peer = this.randomPeer;\n        }\n        if (!peer)\n            throw 'No peer available';\n        if (!peer.protocols.includes(exports.LightPushCodec))\n            throw 'Peer does not register waku light push protocol';\n        const connection = this.libp2p.connectionManager.get(peer.id);\n        if (!connection)\n            throw 'Failed to get a connection to the peer';\n        const { stream } = await connection.newStream(exports.LightPushCodec);\n        try {\n            const pubSubTopic = (opts === null || opts === void 0 ? void 0 : opts.pubSubTopic)\n                ? opts.pubSubTopic\n                : this.pubSubTopic;\n            const query = push_rpc_1.PushRPC.createRequest(message, pubSubTopic);\n            const res = await it_pipe_1.default([query.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);\n            try {\n                const response = push_rpc_1.PushRPC.decode(res.slice()).response;\n                if (!response) {\n                    console.log('No response in PushRPC');\n                    return null;\n                }\n                return response;\n            }\n            catch (err) {\n                console.log('Failed to decode push reply', err);\n            }\n        }\n        catch (err) {\n            console.log('Failed to send waku light push request', err);\n        }\n        return null;\n    }\n    /**\n     * Returns known peers from the address book (`libp2p.peerStore`) that support\n     * light push protocol. Waku may or  may not be currently connected to these peers.\n     */\n    get peers() {\n        return select_peer_1.getPeersForProtocol(this.libp2p, exports.LightPushCodec);\n    }\n    /**\n     * Returns a random peer that supports light push protocol from the address\n     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to\n     * this peer.\n     */\n    get randomPeer() {\n        return select_peer_1.selectRandomPeer(this.peers);\n    }\n}\nexports.WakuLightPush = WakuLightPush;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PushRPC = exports.PushResponse = exports.PushRequest = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst message_1 = require(\"../../waku/v2/message\");\nexports.protobufPackage = 'waku.v2';\nconst basePushRequest = { pubSubTopic: '' };\nexports.PushRequest = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.pubSubTopic !== '') {\n            writer.uint32(10).string(message.pubSubTopic);\n        }\n        if (message.message !== undefined) {\n            message_1.WakuMessage.encode(message.message, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, basePushRequest);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pubSubTopic = reader.string();\n                    break;\n                case 2:\n                    message.message = message_1.WakuMessage.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, basePushRequest);\n        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {\n            message.pubSubTopic = String(object.pubSubTopic);\n        }\n        else {\n            message.pubSubTopic = '';\n        }\n        if (object.message !== undefined && object.message !== null) {\n            message.message = message_1.WakuMessage.fromJSON(object.message);\n        }\n        else {\n            message.message = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pubSubTopic !== undefined &&\n            (obj.pubSubTopic = message.pubSubTopic);\n        message.message !== undefined &&\n            (obj.message = message.message\n                ? message_1.WakuMessage.toJSON(message.message)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, basePushRequest);\n        if (object.pubSubTopic !== undefined && object.pubSubTopic !== null) {\n            message.pubSubTopic = object.pubSubTopic;\n        }\n        else {\n            message.pubSubTopic = '';\n        }\n        if (object.message !== undefined && object.message !== null) {\n            message.message = message_1.WakuMessage.fromPartial(object.message);\n        }\n        else {\n            message.message = undefined;\n        }\n        return message;\n    },\n};\nconst basePushResponse = { isSuccess: false, info: '' };\nexports.PushResponse = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.isSuccess === true) {\n            writer.uint32(8).bool(message.isSuccess);\n        }\n        if (message.info !== '') {\n            writer.uint32(18).string(message.info);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, basePushResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isSuccess = reader.bool();\n                    break;\n                case 2:\n                    message.info = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, basePushResponse);\n        if (object.isSuccess !== undefined && object.isSuccess !== null) {\n            message.isSuccess = Boolean(object.isSuccess);\n        }\n        else {\n            message.isSuccess = false;\n        }\n        if (object.info !== undefined && object.info !== null) {\n            message.info = String(object.info);\n        }\n        else {\n            message.info = '';\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isSuccess !== undefined && (obj.isSuccess = message.isSuccess);\n        message.info !== undefined && (obj.info = message.info);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, basePushResponse);\n        if (object.isSuccess !== undefined && object.isSuccess !== null) {\n            message.isSuccess = object.isSuccess;\n        }\n        else {\n            message.isSuccess = false;\n        }\n        if (object.info !== undefined && object.info !== null) {\n            message.info = object.info;\n        }\n        else {\n            message.info = '';\n        }\n        return message;\n    },\n};\nconst basePushRPC = { requestId: '' };\nexports.PushRPC = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.requestId !== '') {\n            writer.uint32(10).string(message.requestId);\n        }\n        if (message.request !== undefined) {\n            exports.PushRequest.encode(message.request, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.response !== undefined) {\n            exports.PushResponse.encode(message.response, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, basePushRPC);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.string();\n                    break;\n                case 2:\n                    message.request = exports.PushRequest.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.response = exports.PushResponse.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, basePushRPC);\n        if (object.requestId !== undefined && object.requestId !== null) {\n            message.requestId = String(object.requestId);\n        }\n        else {\n            message.requestId = '';\n        }\n        if (object.request !== undefined && object.request !== null) {\n            message.request = exports.PushRequest.fromJSON(object.request);\n        }\n        else {\n            message.request = undefined;\n        }\n        if (object.response !== undefined && object.response !== null) {\n            message.response = exports.PushResponse.fromJSON(object.response);\n        }\n        else {\n            message.response = undefined;\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.requestId !== undefined && (obj.requestId = message.requestId);\n        message.request !== undefined &&\n            (obj.request = message.request\n                ? exports.PushRequest.toJSON(message.request)\n                : undefined);\n        message.response !== undefined &&\n            (obj.response = message.response\n                ? exports.PushResponse.toJSON(message.response)\n                : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, basePushRPC);\n        if (object.requestId !== undefined && object.requestId !== null) {\n            message.requestId = object.requestId;\n        }\n        else {\n            message.requestId = '';\n        }\n        if (object.request !== undefined && object.request !== null) {\n            message.request = exports.PushRequest.fromPartial(object.request);\n        }\n        else {\n            message.request = undefined;\n        }\n        if (object.response !== undefined && object.response !== null) {\n            message.response = exports.PushResponse.fromPartial(object.response);\n        }\n        else {\n            message.response = undefined;\n        }\n        return message;\n    },\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=light_push.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPeersForProtocol = exports.selectRandomPeer = void 0;\n/**\n * Returns a pseudo-random peer that supports the given protocol.\n * Useful for protocols such as store and light push\n */\nfunction selectRandomPeer(peers) {\n    if (peers.length === 0)\n        return;\n    const index = Math.round(Math.random() * (peers.length - 1));\n    return peers[index];\n}\nexports.selectRandomPeer = selectRandomPeer;\n/**\n * Returns the list of peers that supports the given protocol.\n */\nfunction getPeersForProtocol(libp2p, protocol) {\n    return Array.from(libp2p.peerStore.peers.values()).filter((peer) => peer.protocols.includes(protocol));\n}\nexports.getPeersForProtocol = getPeersForProtocol;\n//# sourceMappingURL=select_peer.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPublicKey = exports.generatePrivateKey = exports.decryptSymmetric = exports.encryptSymmetric = exports.decryptAsymmetric = exports.encryptAsymmetric = exports.clearDecode = exports.clearEncode = void 0;\nconst buffer_1 = require(\"buffer\");\nconst crypto = __importStar(require(\"crypto\"));\nconst ecies = __importStar(require(\"ecies-geth\"));\nconst js_sha3_1 = require(\"js-sha3\");\nconst secp256k1 = __importStar(require(\"secp256k1\"));\nconst utils_1 = require(\"../utils\");\nconst symmetric_1 = require(\"./symmetric\");\nconst FlagsLength = 1;\nconst FlagMask = 3; // 0011\nconst IsSignedMask = 4; // 0100\nconst PaddingTarget = 256;\nconst SignatureLength = 65;\n/**\n * Encode the payload pre-encryption.\n *\n * @internal\n * @param messagePayload: The payload to include in the message\n * @param sigPrivKey: If set, a signature using this private key is added.\n * @returns The encoded payload, ready for encryption using {@link encryptAsymmetric}\n * or {@link encryptSymmetric}.\n */\nfunction clearEncode(messagePayload, sigPrivKey) {\n    let envelope = buffer_1.Buffer.from([0]); // No flags\n    envelope = addPayloadSizeField(envelope, messagePayload);\n    envelope = buffer_1.Buffer.concat([envelope, buffer_1.Buffer.from(messagePayload)]);\n    // Calculate padding:\n    let rawSize = FlagsLength +\n        getSizeOfPayloadSizeField(messagePayload) +\n        messagePayload.length;\n    if (sigPrivKey) {\n        rawSize += SignatureLength;\n    }\n    const remainder = rawSize % PaddingTarget;\n    const paddingSize = PaddingTarget - remainder;\n    const pad = buffer_1.Buffer.from(randomBytes(paddingSize));\n    if (!validateDataIntegrity(pad, paddingSize)) {\n        throw new Error('failed to generate random padding of size ' + paddingSize);\n    }\n    envelope = buffer_1.Buffer.concat([envelope, pad]);\n    let sig;\n    if (sigPrivKey) {\n        envelope[0] |= IsSignedMask;\n        const hash = js_sha3_1.keccak256(envelope);\n        const s = secp256k1.ecdsaSign(utils_1.hexToBuf(hash), sigPrivKey);\n        envelope = buffer_1.Buffer.concat([envelope, s.signature, buffer_1.Buffer.from([s.recid])]);\n        sig = {\n            signature: buffer_1.Buffer.from(s.signature),\n            publicKey: getPublicKey(sigPrivKey),\n        };\n    }\n    return { payload: envelope, sig };\n}\nexports.clearEncode = clearEncode;\n/**\n * Decode a decrypted payload.\n *\n * @internal\n */\nfunction clearDecode(message) {\n    const buf = buffer_1.Buffer.from(message);\n    let start = 1;\n    let sig;\n    const sizeOfPayloadSizeField = buf.readUIntLE(0, 1) & FlagMask;\n    if (sizeOfPayloadSizeField === 0)\n        return;\n    const payloadSize = buf.readUIntLE(start, sizeOfPayloadSizeField);\n    start += sizeOfPayloadSizeField;\n    const payload = buf.slice(start, start + payloadSize);\n    const isSigned = (buf.readUIntLE(0, 1) & IsSignedMask) == IsSignedMask;\n    if (isSigned) {\n        const signature = getSignature(buf);\n        const hash = getHash(buf, isSigned);\n        const publicKey = ecRecoverPubKey(hash, signature);\n        sig = { signature, publicKey };\n    }\n    return { payload, sig };\n}\nexports.clearDecode = clearDecode;\n/**\n * Proceed with Asymmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n * The data MUST be flags | payload-length | payload | [signature].\n * The returned result can be set to `WakuMessage.payload`.\n *\n * @internal\n */\nasync function encryptAsymmetric(data, publicKey) {\n    return ecies.encrypt(utils_1.hexToBuf(publicKey), buffer_1.Buffer.from(data));\n}\nexports.encryptAsymmetric = encryptAsymmetric;\n/**\n * Proceed with Asymmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n * The return data is expect to be flags | payload-length | payload | [signature].\n *\n * @internal\n */\nasync function decryptAsymmetric(payload, privKey) {\n    return ecies.decrypt(buffer_1.Buffer.from(privKey), buffer_1.Buffer.from(payload));\n}\nexports.decryptAsymmetric = decryptAsymmetric;\n/**\n * Proceed with Symmetric encryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n *\n * @param data The data to encrypt, expected to be `flags | payload-length | payload | [signature]`.\n * @param key The key to use for encryption.\n * @returns The decrypted data, `cipherText | tag | iv` and can be set to `WakuMessage.payload`.\n *\n * @internal\n */\nasync function encryptSymmetric(data, key) {\n    const iv = symmetric_1.symmetric.generateIv();\n    // Returns `cipher | tag`\n    const cipher = await symmetric_1.symmetric.encrypt(iv, utils_1.hexToBuf(key), buffer_1.Buffer.from(data));\n    return buffer_1.Buffer.concat([cipher, iv]);\n}\nexports.encryptSymmetric = encryptSymmetric;\n/**\n * Proceed with Symmetric decryption of the data as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n *\n * @param payload The cipher data, it is expected to be `cipherText | tag | iv`.\n * @param key The key to use for decryption.\n * @returns The decrypted data, expected to be `flags | payload-length | payload | [signature]`.\n *\n * @internal\n */\nasync function decryptSymmetric(payload, key) {\n    const data = buffer_1.Buffer.from(payload);\n    const ivStart = data.length - symmetric_1.IvSize;\n    const cipher = data.slice(0, ivStart);\n    const iv = data.slice(ivStart);\n    return symmetric_1.symmetric.decrypt(iv, utils_1.hexToBuf(key), cipher);\n}\nexports.decryptSymmetric = decryptSymmetric;\n/**\n * Generate a new key. Can be used as a private key for Asymmetric encryption\n * or a key for symmetric encryption.\n *\n * If using Asymmetric encryption, use {@link getPublicKey} to get the\n * corresponding Public Key.\n */\nfunction generatePrivateKey() {\n    return randomBytes(32);\n}\nexports.generatePrivateKey = generatePrivateKey;\n/**\n * Return the public key for the given private key, to be used for asymmetric\n * encryption.\n */\nfunction getPublicKey(privateKey) {\n    return secp256k1.publicKeyCreate(privateKey, false);\n}\nexports.getPublicKey = getPublicKey;\n/**\n * Computes the flags & auxiliary-field as per [26/WAKU-PAYLOAD](https://rfc.vac.dev/spec/26/).\n */\nfunction addPayloadSizeField(msg, payload) {\n    const fieldSize = getSizeOfPayloadSizeField(payload);\n    let field = buffer_1.Buffer.alloc(4);\n    field.writeUInt32LE(payload.length, 0);\n    field = field.slice(0, fieldSize);\n    msg = buffer_1.Buffer.concat([msg, field]);\n    msg[0] |= fieldSize;\n    return msg;\n}\n/**\n * Returns the size of the auxiliary-field which in turns contains the payload size\n */\nfunction getSizeOfPayloadSizeField(payload) {\n    let s = 1;\n    for (let i = payload.length; i >= 256; i /= 256) {\n        s++;\n    }\n    return s;\n}\nfunction validateDataIntegrity(value, expectedSize) {\n    if (value.length !== expectedSize) {\n        return false;\n    }\n    return !(expectedSize > 3 && buffer_1.Buffer.from(value).equals(buffer_1.Buffer.alloc(value.length)));\n}\nfunction getSignature(message) {\n    return message.slice(message.length - SignatureLength, message.length);\n}\nfunction getHash(message, isSigned) {\n    if (isSigned) {\n        return js_sha3_1.keccak256(message.slice(0, message.length - SignatureLength));\n    }\n    return js_sha3_1.keccak256(message);\n}\nfunction ecRecoverPubKey(messageHash, signature) {\n    const recovery = signature.slice(64).readIntBE(0, 1);\n    return secp256k1.ecdsaRecover(signature.slice(0, 64), recovery, utils_1.hexToBuf(messageHash), false);\n}\nfunction randomBytes(length) {\n    if (typeof window !== 'undefined' && window && window.crypto) {\n        const array = new Uint8Array(length);\n        window.crypto.getRandomValues(array);\n        return array;\n    }\n    else {\n        return crypto.randomBytes(length);\n    }\n}\n//# sourceMappingURL=version_1.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getRelayPeers = void 0;\nconst utils_1 = require(\"libp2p-gossipsub/src/utils\");\nconst index_1 = require(\"./index\");\n/**\n * Given a topic, returns up to count peers subscribed to that topic\n * that pass an optional filter function\n *\n * @param {Gossipsub} router\n * @param {String} topic\n * @param {Number} count\n * @param {Function} [filter] a function to filter acceptable peers\n * @returns {Set<string>}\n *\n */\nfunction getRelayPeers(router, topic, count, filter = () => true) {\n    const peersInTopic = router.topics.get(topic);\n    if (!peersInTopic) {\n        return new Set();\n    }\n    // Adds all peers using our protocol\n    // that also pass the filter function\n    let peers = [];\n    peersInTopic.forEach((id) => {\n        const peerStreams = router.peers.get(id);\n        if (!peerStreams) {\n            return;\n        }\n        if (index_1.RelayCodecs.includes(peerStreams.protocol) && filter(id)) {\n            peers.push(id);\n        }\n    });\n    // Pseudo-randomly shuffles peers\n    peers = utils_1.shuffle(peers);\n    if (count > 0 && peers.length > count) {\n        peers = peers.slice(0, count);\n    }\n    return new Set(peers);\n}\nexports.getRelayPeers = getRelayPeers;\n//# sourceMappingURL=get_relay_peers.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WakuStore = exports.Direction = exports.StoreCodec = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst it_concat_1 = __importDefault(require(\"it-concat\"));\nconst it_length_prefixed_1 = __importDefault(require(\"it-length-prefixed\"));\nconst it_pipe_1 = __importDefault(require(\"it-pipe\"));\nconst store_1 = require(\"../../proto/waku/v2/store\");\nconst select_peer_1 = require(\"../select_peer\");\nconst waku_1 = require(\"../waku\");\nconst waku_message_1 = require(\"../waku_message\");\nconst history_rpc_1 = require(\"./history_rpc\");\nObject.defineProperty(exports, \"Direction\", { enumerable: true, get: function () { return history_rpc_1.Direction; } });\nconst dbg = debug_1.default('waku:store');\nexports.StoreCodec = '/vac/waku/store/2.0.0-beta3';\n/**\n * Implements the [Waku v2 Store protocol](https://rfc.vac.dev/spec/13/).\n */\nclass WakuStore {\n    constructor(libp2p, options) {\n        this.libp2p = libp2p;\n        if (options === null || options === void 0 ? void 0 : options.pubSubTopic) {\n            this.pubSubTopic = options.pubSubTopic;\n        }\n        else {\n            this.pubSubTopic = waku_1.DefaultPubSubTopic;\n        }\n    }\n    /**\n     * Query given peer using Waku Store.\n     *\n     * @param contentTopics The content topics to pass to the query, leave empty to\n     * retrieve all messages.\n     * @param options\n     * @param options.peerId The peer to query.Options\n     * @param options.timeFilter Query messages with a timestamp within the provided values.\n     * @param options.pubSubTopic The pubsub topic to pass to the query. Defaults\n     * to the value set at creation. See [Waku v2 Topic Usage Recommendations](https://rfc.vac.dev/spec/23/).\n     * @param options.callback Callback called on page of stored messages as they are retrieved\n     * @param options.decryptionKeys Keys that will be used to decrypt messages.\n     * It can be Asymmetric Private Keys and Symmetric Keys in the same array, all keys will be tried with both\n     * methods.\n     * @throws If not able to reach the peer to query or error when processing the reply.\n     */\n    async queryHistory(contentTopics, options) {\n        var _a, _b, _c, _d;\n        let startTime, endTime;\n        if (options === null || options === void 0 ? void 0 : options.timeFilter) {\n            startTime = options.timeFilter.startTime.getTime() / 1000;\n            endTime = options.timeFilter.endTime.getTime() / 1000;\n        }\n        const opts = Object.assign({\n            pubSubTopic: this.pubSubTopic,\n            direction: history_rpc_1.Direction.BACKWARD,\n            pageSize: 10,\n        }, options, {\n            startTime,\n            endTime,\n        }, { contentTopics });\n        dbg('Querying history with the following options', options);\n        let peer;\n        if (opts.peerId) {\n            peer = this.libp2p.peerStore.get(opts.peerId);\n            if (!peer)\n                throw 'Peer is unknown';\n        }\n        else {\n            peer = this.randomPeer;\n        }\n        if (!peer)\n            throw 'No peer available';\n        if (!peer.protocols.includes(exports.StoreCodec))\n            throw 'Peer does not register waku store protocol';\n        const connection = this.libp2p.connectionManager.get(peer.id);\n        if (!connection)\n            throw 'Failed to get a connection to the peer';\n        const messages = [];\n        let cursor = undefined;\n        while (true) {\n            const { stream } = await connection.newStream(exports.StoreCodec);\n            const queryOpts = Object.assign(opts, { cursor });\n            const historyRpcQuery = history_rpc_1.HistoryRPC.createQuery(queryOpts);\n            const res = await it_pipe_1.default([historyRpcQuery.encode()], it_length_prefixed_1.default.encode(), stream, it_length_prefixed_1.default.decode(), it_concat_1.default);\n            const reply = history_rpc_1.HistoryRPC.decode(res.slice());\n            const response = reply.response;\n            if (!response) {\n                throw 'History response misses response field';\n            }\n            if (response.error &&\n                response.error === store_1.HistoryResponse_Error.ERROR_INVALID_CURSOR) {\n                throw 'History response contains an Error: INVALID CURSOR';\n            }\n            if (!response.messages || !response.messages.length) {\n                // No messages left (or stored)\n                console.log('No messages present in HistoryRPC response');\n                return messages;\n            }\n            dbg(`${response.messages.length} messages retrieved for pubsub topic ${opts.pubSubTopic}`);\n            const pageMessages = [];\n            await Promise.all(response.messages.map(async (protoMsg) => {\n                const msg = await waku_message_1.WakuMessage.decodeProto(protoMsg, opts.decryptionKeys);\n                if (msg) {\n                    messages.push(msg);\n                    pageMessages.push(msg);\n                }\n            }));\n            if (opts.callback) {\n                // TODO: Test the callback feature\n                // TODO: Change callback to take individual messages\n                opts.callback(pageMessages);\n            }\n            const responsePageSize = (_a = response.pagingInfo) === null || _a === void 0 ? void 0 : _a.pageSize;\n            const queryPageSize = (_c = (_b = historyRpcQuery.query) === null || _b === void 0 ? void 0 : _b.pagingInfo) === null || _c === void 0 ? void 0 : _c.pageSize;\n            if (responsePageSize &&\n                queryPageSize &&\n                responsePageSize < queryPageSize) {\n                // Response page size smaller than query, meaning this is the last page\n                return messages;\n            }\n            cursor = (_d = response.pagingInfo) === null || _d === void 0 ? void 0 : _d.cursor;\n            if (cursor === undefined) {\n                // If the server does not return cursor then there is an issue,\n                // Need to abort or we end up in an infinite loop\n                console.log('No cursor returned by peer.');\n                return messages;\n            }\n        }\n    }\n    /**\n     * Returns known peers from the address book (`libp2p.peerStore`) that support\n     * store protocol. Waku may or  may not be currently connected to these peers.\n     */\n    get peers() {\n        return select_peer_1.getPeersForProtocol(this.libp2p, exports.StoreCodec);\n    }\n    /**\n     * Returns a random peer that supports store protocol from the address\n     * book (`libp2p.peerStore`). Waku may or  may not be currently connected to\n     * this peer.\n     */\n    get randomPeer() {\n        return select_peer_1.selectRandomPeer(this.peers);\n    }\n}\nexports.WakuStore = WakuStore;\n//# sourceMappingURL=index.js.map","import { multiaddr } from 'multiaddr';\nimport PeerId from 'peer-id';\nimport { Waku } from 'js-waku';\n\nfunction help(): string[] {\n  return [\n    '/nick <nickname>: set a new nickname',\n    '/info: some information about the node',\n    '/connect <Multiaddr>: connect to the given peer',\n    '/help: Display this help',\n  ];\n}\n\nfunction nick(\n  nick: string | undefined,\n  setNick: (nick: string) => void\n): string[] {\n  if (!nick) {\n    return ['No nick provided'];\n  }\n  setNick(nick);\n  return [`New nick: ${nick}`];\n}\n\nfunction info(waku: Waku | undefined): string[] {\n  if (!waku) {\n    return ['Waku node is starting'];\n  }\n  return [`PeerId: ${waku.libp2p.peerId.toB58String()}`];\n}\n\nfunction connect(peer: string | undefined, waku: Waku | undefined): string[] {\n  if (!waku) {\n    return ['Waku node is starting'];\n  }\n  if (!peer) {\n    return ['No peer provided'];\n  }\n  try {\n    const peerMultiaddr = multiaddr(peer);\n    const peerId = peerMultiaddr.getPeerId();\n    if (!peerId) {\n      return ['Peer Id needed to dial'];\n    }\n    waku.addPeerToAddressBook(PeerId.createFromB58String(peerId), [\n      peerMultiaddr,\n    ]);\n    return [\n      `${peerId}: ${peerMultiaddr.toString()} added to address book, autodial in progress`,\n    ];\n  } catch (e) {\n    return ['Invalid multiaddr: ' + e];\n  }\n}\n\nfunction peers(waku: Waku | undefined): string[] {\n  if (!waku) {\n    return ['Waku node is starting'];\n  }\n  let response: string[] = [];\n  waku.libp2p.peerStore.peers.forEach((peer, peerId) => {\n    response.push(peerId + ':');\n    let addresses = '  addresses: [';\n    peer.addresses.forEach(({ multiaddr }) => {\n      addresses += ' ' + multiaddr.toString() + ',';\n    });\n    addresses = addresses.replace(/,$/, '');\n    addresses += ']';\n    response.push(addresses);\n    let protocols = '  protocols: [';\n    protocols += peer.protocols;\n    protocols += ']';\n    response.push(protocols);\n  });\n  if (response.length === 0) {\n    response.push('Not connected to any peer.');\n  }\n  return response;\n}\n\nfunction connections(waku: Waku | undefined): string[] {\n  if (!waku) {\n    return ['Waku node is starting'];\n  }\n  let response: string[] = [];\n  waku.libp2p.connections.forEach(\n    (\n      connections: import('libp2p-interfaces/src/connection/connection')[],\n      peerId\n    ) => {\n      response.push(peerId + ':');\n      let strConnections = '  connections: [';\n      connections.forEach((connection) => {\n        strConnections += JSON.stringify(connection.stat);\n        strConnections += '; ' + JSON.stringify(connection.streams);\n      });\n      strConnections += ']';\n      response.push(strConnections);\n    }\n  );\n  if (response.length === 0) {\n    response.push('Not connected to any peer.');\n  }\n  return response;\n}\n\nexport default function handleCommand(\n  input: string,\n  waku: Waku | undefined,\n  setNick: (nick: string) => void\n): { command: string; response: string[] } {\n  let response: string[] = [];\n  const args = parseInput(input);\n  const command = args.shift()!;\n  switch (command) {\n    case '/help':\n      help().map((str) => response.push(str));\n      break;\n    case '/nick':\n      nick(args.shift(), setNick).map((str) => response.push(str));\n      break;\n    case '/info':\n      info(waku).map((str) => response.push(str));\n      break;\n    case '/connect':\n      connect(args.shift(), waku).map((str) => response.push(str));\n      break;\n    case '/peers':\n      peers(waku).map((str) => response.push(str));\n      break;\n    case '/connections':\n      connections(waku).map((str) => response.push(str));\n      break;\n    default:\n      response.push(`Unknown Command '${command}'`);\n  }\n  return { command, response };\n}\n\nexport function parseInput(input: string): string[] {\n  const clean = input.trim().replaceAll(/\\s\\s+/g, ' ');\n  return clean.split(' ');\n}\n","import { memo, useEffect, useRef } from 'react';\nimport {\n  Message as LiveMessage,\n  MessageText,\n  MessageList,\n} from '@livechat/ui-kit';\nimport { Message } from './Message';\n\ninterface Props {\n  messages: Message[];\n}\n\nmemo(ChatList);\n\nexport default function ChatList(props: Props) {\n  const renderedMessages = props.messages.map((message) => (\n    <LiveMessage\n      key={\n        message.sentTimestamp\n          ? message.sentTimestamp.valueOf()\n          : '' +\n            message.timestamp.valueOf() +\n            message.nick +\n            message.payloadAsUtf8\n      }\n      authorName={message.nick}\n      date={formatDisplayDate(message)}\n    >\n      <MessageText>{message.payloadAsUtf8}</MessageText>\n    </LiveMessage>\n  ));\n\n  return (\n    <MessageList active containScrollInSubtree>\n      {renderedMessages}\n      <AlwaysScrollToBottom messages={props.messages} />\n    </MessageList>\n  );\n}\n\nfunction formatDisplayDate(message: Message): string {\n  return message.timestamp.toLocaleString([], {\n    month: 'short',\n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n    hour12: false,\n  });\n}\n\nconst AlwaysScrollToBottom = (props: { messages: Message[] }) => {\n  const elementRef = useRef<HTMLDivElement>();\n\n  useEffect(() => {\n    // @ts-ignore\n    elementRef.current.scrollIntoView();\n  }, [props.messages]);\n\n  // @ts-ignore\n  return <div ref={elementRef} />;\n};\n","import { ChangeEvent, KeyboardEvent, useState } from 'react';\nimport { useWaku } from './WakuContext';\nimport {\n  TextInput,\n  TextComposer,\n  Row,\n  Fill,\n  Fit,\n  SendButton,\n} from '@livechat/ui-kit';\n\ninterface Props {\n  sendMessage: ((msg: string) => Promise<void>) | undefined;\n}\n\nexport default function MessageInput(props: Props) {\n  const [inputText, setInputText] = useState<string>('');\n  const { waku } = useWaku();\n\n  const sendMessage = async () => {\n    if (props.sendMessage) {\n      await props.sendMessage(inputText);\n      setInputText('');\n    }\n  };\n\n  const messageHandler = (event: ChangeEvent<HTMLInputElement>) => {\n    setInputText(event.target.value);\n  };\n\n  const keyPressHandler = async (event: KeyboardEvent<HTMLInputElement>) => {\n    if (\n      event.key === 'Enter' &&\n      !event.altKey &&\n      !event.ctrlKey &&\n      !event.shiftKey\n    ) {\n      await sendMessage();\n    }\n  };\n\n  // Enable the button if there are relay peers available or the user is sending a command\n  const activeButton =\n    (waku && waku.relay.getPeers().size !== 0) || inputText.startsWith('/');\n\n  return (\n    <TextComposer\n      onKeyDown={keyPressHandler}\n      onChange={messageHandler}\n      active={activeButton}\n      onButtonClick={sendMessage}\n    >\n      <Row align=\"center\">\n        <Fill>\n          <TextInput value={inputText} />\n        </Fill>\n        <Fit>\n          <SendButton />\n        </Fit>\n      </Row>\n    </TextComposer>\n  );\n}\n","import { WakuMessage } from 'js-waku';\nimport { ChatContentTopic } from './App';\nimport ChatList from './ChatList';\nimport MessageInput from './MessageInput';\nimport { useWaku } from './WakuContext';\nimport { TitleBar } from '@livechat/ui-kit';\nimport { Message } from './Message';\nimport { ChatMessage } from './chat_message';\n\ninterface Props {\n  messages: Message[];\n  commandHandler: (cmd: string) => void;\n  nick: string;\n}\n\nexport default function Room(props: Props) {\n  const { waku } = useWaku();\n\n  let relayPeers = 0;\n  let storePeers = 0;\n  if (waku) {\n    relayPeers = waku.relay.getPeers().size;\n    storePeers = waku.store.peers.length;\n  }\n\n  return (\n    <div\n      className=\"chat-container\"\n      style={{ height: '98vh', display: 'flex', flexDirection: 'column' }}\n    >\n      <TitleBar\n        leftIcons={`Peers: ${relayPeers} relay, ${storePeers} store.`}\n        title=\"Waku v2 chat app\"\n      />\n      <ChatList messages={props.messages} />\n      <MessageInput\n        sendMessage={\n          waku\n            ? async (messageToSend) => {\n                return handleMessage(\n                  messageToSend,\n                  props.nick,\n                  props.commandHandler,\n                  waku.relay.send.bind(waku.relay)\n                );\n              }\n            : undefined\n        }\n      />\n    </div>\n  );\n}\n\nasync function handleMessage(\n  message: string,\n  nick: string,\n  commandHandler: (cmd: string) => void,\n  messageSender: (msg: WakuMessage) => Promise<void>\n) {\n  if (message.startsWith('/')) {\n    commandHandler(message);\n  } else {\n    const timestamp = new Date();\n    const chatMessage = ChatMessage.fromUtf8String(timestamp, nick, message);\n    const wakuMsg = await WakuMessage.fromBytes(\n      chatMessage.encode(),\n      ChatContentTopic,\n      { timestamp }\n    );\n    return messageSender(wakuMsg);\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PushRPC = void 0;\nconst minimal_1 = require(\"protobufjs/minimal\");\nconst uuid_1 = require(\"uuid\");\nconst proto = __importStar(require(\"../../proto/waku/v2/light_push\"));\nclass PushRPC {\n    constructor(proto) {\n        this.proto = proto;\n    }\n    static createRequest(message, pubSubTopic) {\n        return new PushRPC({\n            requestId: uuid_1.v4(),\n            request: {\n                message: message.proto,\n                pubSubTopic: pubSubTopic,\n            },\n            response: undefined,\n        });\n    }\n    static decode(bytes) {\n        const res = proto.PushRPC.decode(minimal_1.Reader.create(bytes));\n        return new PushRPC(res);\n    }\n    encode() {\n        return proto.PushRPC.encode(this.proto).finish();\n    }\n    get query() {\n        return this.proto.request;\n    }\n    get response() {\n        return this.proto.response;\n    }\n}\nexports.PushRPC = PushRPC;\n//# sourceMappingURL=push_rpc.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateIv = exports.generateKeyForSymmetricEnc = exports.decrypt = exports.encrypt = void 0;\nconst index_1 = require(\"./index\");\nconst crypto = window.crypto || window.msCrypto;\nconst subtle = crypto.subtle || crypto.webkitSubtle;\nconst Algorithm = { name: 'AES-GCM', length: 128 };\nif (subtle === undefined) {\n    throw new Error('Failed to load Subtle CryptoAPI');\n}\nasync function encrypt(iv, key, clearText) {\n    return subtle\n        .importKey('raw', key, Algorithm, false, ['encrypt'])\n        .then((cryptoKey) => subtle.encrypt(Object.assign({ iv }, Algorithm), cryptoKey, clearText))\n        .then(Buffer.from);\n}\nexports.encrypt = encrypt;\nasync function decrypt(iv, key, cipherText) {\n    return subtle\n        .importKey('raw', key, Algorithm, false, ['decrypt'])\n        .then((cryptoKey) => subtle.decrypt(Object.assign({ iv }, Algorithm), cryptoKey, cipherText))\n        .then(Buffer.from);\n}\nexports.decrypt = decrypt;\nfunction generateKeyForSymmetricEnc() {\n    return crypto.getRandomValues(Buffer.alloc(index_1.SymmetricKeySize));\n}\nexports.generateKeyForSymmetricEnc = generateKeyForSymmetricEnc;\nfunction generateIv() {\n    const iv = new Uint8Array(index_1.IvSize);\n    crypto.getRandomValues(iv);\n    return iv;\n}\nexports.generateIv = generateIv;\n//# sourceMappingURL=browser.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateIv = exports.generateKeyForSymmetricEnc = exports.decrypt = exports.encrypt = void 0;\nconst crypto_1 = require(\"crypto\");\nconst index_1 = require(\"./index\");\nconst Algorithm = 'aes-256-gcm';\nasync function encrypt(iv, key, clearText) {\n    const cipher = crypto_1.createCipheriv(Algorithm, key, iv);\n    const a = cipher.update(clearText);\n    const b = cipher.final();\n    const tag = cipher.getAuthTag();\n    return Buffer.concat([a, b, tag]);\n}\nexports.encrypt = encrypt;\nasync function decrypt(iv, key, data) {\n    const tagStart = data.length - index_1.TagSize;\n    const cipherText = data.slice(0, tagStart);\n    const tag = data.slice(tagStart);\n    const decipher = crypto_1.createDecipheriv(Algorithm, key, iv);\n    decipher.setAuthTag(tag);\n    const a = decipher.update(cipherText);\n    const b = decipher.final();\n    return Buffer.concat([a, b]);\n}\nexports.decrypt = decrypt;\nfunction generateKeyForSymmetricEnc() {\n    return crypto_1.randomBytes(index_1.SymmetricKeySize);\n}\nexports.generateKeyForSymmetricEnc = generateKeyForSymmetricEnc;\nfunction generateIv() {\n    return crypto_1.randomBytes(index_1.IvSize);\n}\nexports.generateIv = generateIv;\n//# sourceMappingURL=node.js.map","\"use strict\";\n/**\n * @hidden\n * @module\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RelayHeartbeat = void 0;\nconst heartbeat_1 = require(\"libp2p-gossipsub/src/heartbeat\");\nconst utils_1 = require(\"libp2p-gossipsub/src/utils\");\nconst constants = __importStar(require(\"./constants\"));\nconst get_relay_peers_1 = require(\"./get_relay_peers\");\nclass RelayHeartbeat extends heartbeat_1.Heartbeat {\n    /**\n     * @param {Object} gossipsub\n     * @constructor\n     */\n    constructor(gossipsub) {\n        super(gossipsub);\n    }\n    start() {\n        if (this._heartbeatTimer) {\n            return;\n        }\n        const heartbeat = this._heartbeat.bind(this);\n        const timeout = setTimeout(() => {\n            var _a;\n            heartbeat();\n            (_a = this._heartbeatTimer) === null || _a === void 0 ? void 0 : _a.runPeriodically(heartbeat, constants.RelayHeartbeatInterval);\n        }, constants.RelayHeartbeatInitialDelay);\n        this._heartbeatTimer = {\n            _intervalId: undefined,\n            runPeriodically: (fn, period) => {\n                // this._heartbeatTimer cannot be null, it is being assigned.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                this._heartbeatTimer._intervalId = setInterval(fn, period);\n            },\n            cancel: () => {\n                var _a;\n                clearTimeout(timeout);\n                clearInterval((_a = this._heartbeatTimer) === null || _a === void 0 ? void 0 : _a._intervalId);\n            },\n        };\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n    stop() {\n        if (!this._heartbeatTimer) {\n            return;\n        }\n        this._heartbeatTimer.cancel();\n        this._heartbeatTimer = null;\n    }\n    /**\n     * Maintains the mesh and fanout maps in gossipsub.\n     *\n     * @returns {void}\n     */\n    _heartbeat() {\n        const { D, Dlo, Dhi, Dscore, Dout } = this.gossipsub._options;\n        this.gossipsub.heartbeatTicks++;\n        // cache scores through the heartbeat\n        const scores = new Map();\n        const getScore = (id) => {\n            let s = scores.get(id);\n            if (s === undefined) {\n                s = this.gossipsub.score.score(id);\n                scores.set(id, s);\n            }\n            return s;\n        };\n        // peer id => topic[]\n        const toGraft = new Map();\n        // peer id => topic[]\n        const toPrune = new Map();\n        // peer id => don't px\n        const noPX = new Map();\n        // clean up expired backoffs\n        this.gossipsub._clearBackoff();\n        // clean up peerhave/iasked counters\n        this.gossipsub.peerhave.clear();\n        this.gossipsub.iasked.clear();\n        // apply IWANT request penalties\n        this.gossipsub._applyIwantPenalties();\n        // ensure direct peers are connected\n        this.gossipsub._directConnect();\n        // maintain the mesh for topics we have joined\n        this.gossipsub.mesh.forEach((peers, topic) => {\n            // prune/graft helper functions (defined per topic)\n            const prunePeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.prune(id, topic);\n                // add prune backoff record\n                this.gossipsub._addBackoff(id, topic);\n                // remove peer from mesh\n                peers.delete(id);\n                // add to toPrune\n                const topics = toPrune.get(id);\n                if (!topics) {\n                    toPrune.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            const graftPeer = (id) => {\n                this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', id, topic);\n                // update peer score\n                this.gossipsub.score.graft(id, topic);\n                // add peer to mesh\n                peers.add(id);\n                // add to toGraft\n                const topics = toGraft.get(id);\n                if (!topics) {\n                    toGraft.set(id, [topic]);\n                }\n                else {\n                    topics.push(topic);\n                }\n            };\n            // drop all peers with negative score, without PX\n            peers.forEach((id) => {\n                const score = getScore(id);\n                if (score < 0) {\n                    this.gossipsub.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic);\n                    prunePeer(id);\n                    noPX.set(id, true);\n                }\n            });\n            // do we have enough peers?\n            if (peers.size < Dlo) {\n                const backoff = this.gossipsub.backoff.get(topic);\n                const ineed = D - peers.size;\n                const peersSet = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {\n                    // filter out mesh peers, direct peers, peers we are backing off, peers with negative score\n                    return (!peers.has(id) &&\n                        !this.gossipsub.direct.has(id) &&\n                        (!backoff || !backoff.has(id)) &&\n                        getScore(id) >= 0);\n                });\n                peersSet.forEach(graftPeer);\n            }\n            // do we have to many peers?\n            if (peers.size > Dhi) {\n                let peersArray = Array.from(peers);\n                // sort by score\n                peersArray.sort((a, b) => getScore(b) - getScore(a));\n                // We keep the first D_score peers by score and the remaining up to D randomly\n                // under the constraint that we keep D_out peers in the mesh (if we have that many)\n                peersArray = peersArray\n                    .slice(0, Dscore)\n                    .concat(utils_1.shuffle(peersArray.slice(Dscore)));\n                // count the outbound peers we are keeping\n                let outbound = 0;\n                peersArray.slice(0, D).forEach((p) => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, bubble up some outbound peers from the random selection\n                if (outbound < Dout) {\n                    const rotate = (i) => {\n                        // rotate the peersArray to the right and put the ith peer in the front\n                        const p = peersArray[i];\n                        for (let j = i; j > 0; j--) {\n                            peersArray[j] = peersArray[j - 1];\n                        }\n                        peersArray[0] = p;\n                    };\n                    // first bubble up all outbound peers already in the selection to the front\n                    if (outbound > 0) {\n                        let ihave = outbound;\n                        for (let i = 1; i < D && ihave > 0; i++) {\n                            if (this.gossipsub.outbound.get(peersArray[i])) {\n                                rotate(i);\n                                ihave--;\n                            }\n                        }\n                    }\n                    // now bubble up enough outbound peers outside the selection to the front\n                    let ineed = D - outbound;\n                    for (let i = D; i < peersArray.length && ineed > 0; i++) {\n                        if (this.gossipsub.outbound.get(peersArray[i])) {\n                            rotate(i);\n                            ineed--;\n                        }\n                    }\n                }\n                // prune the excess peers\n                peersArray.slice(D).forEach(prunePeer);\n            }\n            // do we have enough outbound peers?\n            if (peers.size >= Dlo) {\n                // count the outbound peers we have\n                let outbound = 0;\n                peers.forEach((p) => {\n                    if (this.gossipsub.outbound.get(p)) {\n                        outbound++;\n                    }\n                });\n                // if it's less than D_out, select some peers with outbound connections and graft them\n                if (outbound < Dout) {\n                    const ineed = Dout - outbound;\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {\n                        // filter our current mesh peers, direct peers, peers we are backing off, peers with negative score\n                        return (!peers.has(id) &&\n                            !this.gossipsub.direct.has(id) &&\n                            (!backoff || !backoff.has(id)) &&\n                            getScore(id) >= 0);\n                    }).forEach(graftPeer);\n                }\n            }\n            // should we try to improve the mesh with opportunistic grafting?\n            if (this.gossipsub.heartbeatTicks %\n                constants.RelayOpportunisticGraftTicks ===\n                0 &&\n                peers.size > 1) {\n                // Opportunistic grafting works as follows: we check the median score of peers in the\n                // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n                // random with score over the median.\n                // The intention is to (slowly) improve an under performing mesh by introducing good\n                // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n                // situations where we are stuck with poor peers and also recover from churn of good peers.\n                // now compute the median peer score in the mesh\n                const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));\n                const medianIndex = peers.size / 2;\n                const medianScore = getScore(peersList[medianIndex]);\n                // if the median score is below the threshold, select a better peer (if any) and GRAFT\n                if (medianScore <\n                    this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {\n                    const backoff = this.gossipsub.backoff.get(topic);\n                    const peersToGraft = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, constants.RelayOpportunisticGraftPeers, (id) => {\n                        // filter out current mesh peers, direct peers, peers we are backing off, peers below or at threshold\n                        return (peers.has(id) &&\n                            !this.gossipsub.direct.has(id) &&\n                            (!backoff || !backoff.has(id)) &&\n                            getScore(id) > medianScore);\n                    });\n                    peersToGraft.forEach((id) => {\n                        this.gossipsub.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic);\n                        graftPeer(id);\n                    });\n                }\n            }\n            // 2nd arg are mesh peers excluded from gossip. We have already pushed\n            // messages to them, so its redundant to gossip IHAVEs.\n            this.gossipsub._emitGossip(topic, peers);\n        });\n        // expire fanout for topics we haven't published to in a while\n        const now = this.gossipsub._now();\n        this.gossipsub.lastpub.forEach((lastpub, topic) => {\n            if (lastpub + constants.RelayFanoutTTL < now) {\n                this.gossipsub.fanout.delete(topic);\n                this.gossipsub.lastpub.delete(topic);\n            }\n        });\n        // maintain our fanout for topics we are publishing but we have not joined\n        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {\n            // checks whether our peers are still in the topic and have a score above the publish threshold\n            const topicPeers = this.gossipsub.topics.get(topic);\n            fanoutPeers.forEach((id) => {\n                if (!(topicPeers === null || topicPeers === void 0 ? void 0 : topicPeers.has(id)) ||\n                    getScore(id) <\n                        this.gossipsub._options.scoreThresholds.publishThreshold) {\n                    fanoutPeers.delete(id);\n                }\n            });\n            // do we need more peers?\n            if (fanoutPeers.size < D) {\n                const ineed = D - fanoutPeers.size;\n                const peersSet = get_relay_peers_1.getRelayPeers(this.gossipsub, topic, ineed, (id) => {\n                    // filter out existing fanout peers, direct peers, and peers with score above the publish threshold\n                    return (!fanoutPeers.has(id) &&\n                        !this.gossipsub.direct.has(id) &&\n                        getScore(id) >=\n                            this.gossipsub._options.scoreThresholds.publishThreshold);\n                });\n                peersSet.forEach((id) => {\n                    fanoutPeers.add(id);\n                });\n            }\n            // 2nd arg are fanout peers excluded from gossip.\n            // We have already pushed messages to them, so its redundant to gossip IHAVEs\n            this.gossipsub._emitGossip(topic, fanoutPeers);\n        });\n        // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n        this.gossipsub._sendGraftPrune(toGraft, toPrune, noPX);\n        // flush pending gossip that wasn't piggybacked above\n        this.gossipsub._flush();\n        // advance the message history window\n        this.gossipsub.messageCache.shift();\n        this.gossipsub.emit('gossipsub:heartbeat');\n    }\n}\nexports.RelayHeartbeat = RelayHeartbeat;\n//# sourceMappingURL=relay_heartbeat.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryRPC = exports.Direction = void 0;\nconst minimal_1 = require(\"protobufjs/minimal\");\nconst uuid_1 = require(\"uuid\");\nconst proto = __importStar(require(\"../../proto/waku/v2/store\"));\nvar Direction;\n(function (Direction) {\n    Direction[\"BACKWARD\"] = \"backward\";\n    Direction[\"FORWARD\"] = \"forward\";\n})(Direction = exports.Direction || (exports.Direction = {}));\nclass HistoryRPC {\n    constructor(proto) {\n        this.proto = proto;\n    }\n    /**\n     * Create History Query.\n     */\n    static createQuery(params) {\n        const direction = directionToProto(params.direction);\n        const pagingInfo = {\n            pageSize: params.pageSize,\n            cursor: params.cursor,\n            direction,\n        };\n        const contentFilters = params.contentTopics.map((contentTopic) => {\n            return { contentTopic };\n        });\n        return new HistoryRPC({\n            requestId: uuid_1.v4(),\n            query: {\n                pubSubTopic: params.pubSubTopic,\n                contentFilters,\n                pagingInfo,\n                startTime: params.startTime,\n                endTime: params.endTime,\n            },\n            response: undefined,\n        });\n    }\n    static decode(bytes) {\n        const res = proto.HistoryRPC.decode(minimal_1.Reader.create(bytes));\n        return new HistoryRPC(res);\n    }\n    encode() {\n        return proto.HistoryRPC.encode(this.proto).finish();\n    }\n    get query() {\n        return this.proto.query;\n    }\n    get response() {\n        return this.proto.response;\n    }\n}\nexports.HistoryRPC = HistoryRPC;\nfunction directionToProto(direction) {\n    switch (direction) {\n        case Direction.BACKWARD:\n            return proto.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;\n        case Direction.FORWARD:\n            return proto.PagingInfo_Direction.DIRECTION_FORWARD;\n        default:\n            return proto.PagingInfo_Direction.DIRECTION_BACKWARD_UNSPECIFIED;\n    }\n}\n//# sourceMappingURL=history_rpc.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HistoryRPC = exports.HistoryResponse = exports.HistoryQuery = exports.ContentFilter = exports.PagingInfo_Direction = exports.PagingInfo = exports.Index = exports.WakuMessage = void 0;\nvar message_1 = require(\"./waku/v2/message\");\nObject.defineProperty(exports, \"WakuMessage\", { enumerable: true, get: function () { return message_1.WakuMessage; } });\nvar store_1 = require(\"./waku/v2/store\");\nObject.defineProperty(exports, \"Index\", { enumerable: true, get: function () { return store_1.Index; } });\nObject.defineProperty(exports, \"PagingInfo\", { enumerable: true, get: function () { return store_1.PagingInfo; } });\nObject.defineProperty(exports, \"PagingInfo_Direction\", { enumerable: true, get: function () { return store_1.PagingInfo_Direction; } });\nObject.defineProperty(exports, \"ContentFilter\", { enumerable: true, get: function () { return store_1.ContentFilter; } });\nObject.defineProperty(exports, \"HistoryQuery\", { enumerable: true, get: function () { return store_1.HistoryQuery; } });\nObject.defineProperty(exports, \"HistoryResponse\", { enumerable: true, get: function () { return store_1.HistoryResponse; } });\nObject.defineProperty(exports, \"HistoryRPC\", { enumerable: true, get: function () { return store_1.HistoryRPC; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.proto = exports.StoreCodec = exports.WakuStore = exports.Direction = exports.RelayCodecs = exports.WakuRelay = exports.PushResponse = exports.LightPushCodec = exports.WakuLightPush = exports.getPublicKey = exports.generatePrivateKey = exports.WakuMessage = exports.DefaultPubSubTopic = exports.Waku = exports.utils = exports.getBootstrapNodes = void 0;\nvar discovery_1 = require(\"./lib/discovery\");\nObject.defineProperty(exports, \"getBootstrapNodes\", { enumerable: true, get: function () { return discovery_1.getBootstrapNodes; } });\nexports.utils = __importStar(require(\"./lib/utils\"));\nvar waku_1 = require(\"./lib/waku\");\nObject.defineProperty(exports, \"Waku\", { enumerable: true, get: function () { return waku_1.Waku; } });\nObject.defineProperty(exports, \"DefaultPubSubTopic\", { enumerable: true, get: function () { return waku_1.DefaultPubSubTopic; } });\nvar waku_message_1 = require(\"./lib/waku_message\");\nObject.defineProperty(exports, \"WakuMessage\", { enumerable: true, get: function () { return waku_message_1.WakuMessage; } });\nvar version_1_1 = require(\"./lib/waku_message/version_1\");\nObject.defineProperty(exports, \"generatePrivateKey\", { enumerable: true, get: function () { return version_1_1.generatePrivateKey; } });\nObject.defineProperty(exports, \"getPublicKey\", { enumerable: true, get: function () { return version_1_1.getPublicKey; } });\nvar waku_light_push_1 = require(\"./lib/waku_light_push\");\nObject.defineProperty(exports, \"WakuLightPush\", { enumerable: true, get: function () { return waku_light_push_1.WakuLightPush; } });\nObject.defineProperty(exports, \"LightPushCodec\", { enumerable: true, get: function () { return waku_light_push_1.LightPushCodec; } });\nObject.defineProperty(exports, \"PushResponse\", { enumerable: true, get: function () { return waku_light_push_1.PushResponse; } });\nvar waku_relay_1 = require(\"./lib/waku_relay\");\nObject.defineProperty(exports, \"WakuRelay\", { enumerable: true, get: function () { return waku_relay_1.WakuRelay; } });\nObject.defineProperty(exports, \"RelayCodecs\", { enumerable: true, get: function () { return waku_relay_1.RelayCodecs; } });\nvar waku_store_1 = require(\"./lib/waku_store\");\nObject.defineProperty(exports, \"Direction\", { enumerable: true, get: function () { return waku_store_1.Direction; } });\nObject.defineProperty(exports, \"WakuStore\", { enumerable: true, get: function () { return waku_store_1.WakuStore; } });\nObject.defineProperty(exports, \"StoreCodec\", { enumerable: true, get: function () { return waku_store_1.StoreCodec; } });\nexports.proto = __importStar(require(\"./proto\"));\n//# sourceMappingURL=index.js.map","import { createContext, useContext } from 'react';\nimport { Waku } from 'js-waku';\n\nexport type WakuContextType = {\n  waku?: Waku;\n};\n\nexport const WakuContext = createContext<WakuContextType>({ waku: undefined });\nexport const useWaku = () => useContext(WakuContext);\n"],"sourceRoot":""}